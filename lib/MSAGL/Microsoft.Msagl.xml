<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Msagl</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Msagl.Splines.MinDistCurveCurve">
            <summary>
            Implements the minimal distance between curves functionality
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.MinDistCurveCurve.#ctor(Microsoft.Msagl.Splines.ICurve,Microsoft.Msagl.Splines.ICurve,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            constructor
            </summary>
            <param name="curveAPar">first curve</param>
            <param name="curveBPar">second curve</param>
            <param name="lowBound0">the first curve minimal parameter</param>
            <param name="upperBound0">the first curve maximal parameter</param>
            <param name="lowBound1">the second curve minimal parameter</param>
            <param name="upperBound1">the first curve maximal parameter</param>
            <param name="guess0"></param>
            <param name="guess1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.MinDistCurveCurve.Delta(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            xy - the first row
            uw - the second row
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="u"></param>
            <param name="w"></param>
        </member>
        <member name="T:Microsoft.Msagl.Routing">
            <summary>
            The class responsible for the routing of splines
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CreateSplines">
            <summary>
            The method doing the main work.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.GetNodeCurve(Microsoft.Msagl.Node)">
            <summary>
            returns translated node boundary curve
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.RouterBetweenTwoNodes">
            <summary>
            the router between nodes
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.RouterBetweenTwoNodes.#ctor(Microsoft.Msagl.GeometryGraph)">
            <summary>
            constructor
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:Microsoft.Msagl.RouterBetweenTwoNodes.RouteCurve(Microsoft.Msagl.Node,Microsoft.Msagl.Node,System.Double,System.Double)">
            <summary>
            Routes a spline between two graph nodes. sourcePort and targetPort define the start and end point of the resulting curve:
            startPoint=source.BoundaryCurve[sourcePort] and endPoint=target.BoundaryCurve[target].
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="sourcePort"></param>
            <param name="targetPort"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.RouterBetweenTwoNodes.MinimalPadding">
            <summary>
            the curve should not come to the nodes closer than MinimalPaddin
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.RouterBetweenTwoNodes.MaximalPadding">
            <summary>
            we pad each node but not more than MaximalPadding
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.RestoreData">
            <summary>
            a base class for restoring geometrical objects
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.SuccEnumerator">
            <summary>
            Enumerator of the vertex successors
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.PredEnumerator">
            <summary>
            Enumeration of the vertex predecessors
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.SugiyamaLayoutSettings">
            <summary>
            controls many properties of the layout algorithm
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.LayoutAlgorithmSettings">
            <summary>
            controls many properties of the layout algorithm
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.LayoutAlgorithmSettings.PointSize">
            <summary>
            the size of a point: this parameter could scale all dimensions down
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayoutAlgorithmSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.SugiyamaLayoutSettings.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.SugiyamaLayoutSettings.CalculateLayout(Microsoft.Msagl.GeometryGraph)">
            <summary>
            The only function one needs to call to calculate the layout.
            </summary>
            <param name="msaglGraph">The layout info will be inserted in to the corresponding fields of the graph</param>
        </member>
        <member name="M:Microsoft.Msagl.SugiyamaLayoutSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.SugiyamaLayoutSettings.RepetitionCoefficientForOrdering">
            <summary>
            This coefficient if set to the value greater than 1 will force the algorithm to search for layouts with fewer edge crossings 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.SugiyamaLayoutSettings.RandomSeedForOrdering">
            <summary>
            The seed for the random element inside of the ordering
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.SugiyamaLayoutSettings.NoGainStepsBound">
            <summary>
            Maximal number of sequential steps without gain in the adjacent swap process
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.SugiyamaLayoutSettings.MaxNumberOfPassesInOrdering">
            <summary>
            Maximal number of passes over layers applying the median algorithm in ordering
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.SugiyamaLayoutSettings.GroupSplit">
            <summary>
            The ratio of the group splitting algorithm used in the spatial hierarchy constructions for edge routing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.SugiyamaLayoutSettings.LabelCornersPreserveCoefficient">
            <summary>
            We create a hexagon for a label boundary: this coeffiecient defines the ratio of the top and the bottom side to the width of the label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.SugiyamaLayoutSettings.BrandesThreshold">
            <summary>
            When the number of vertices in the proper layered graph is the threshold or more we switch to
            the faster, but not so accurate, method for x-coordinates calculations.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Couple`2">
            <summary>
            a generic class for representing a couple of entities
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
        </member>
        <member name="M:Microsoft.Msagl.Couple`2.#ctor(`0,`1)">
            <summary>
            create a couple
            </summary>
            <param name="firstElement"></param>
            <param name="secondElement"></param>
        </member>
        <member name="M:Microsoft.Msagl.Couple`2.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Couple`2.Equals(System.Object)">
            <summary>
            overrides the equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Couple`2.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Couple`2.First">
            <summary>
            the first element
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Couple`2.Second">
            <summary>
            the second element
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.RankingLayout">
            <summary>
            Ranking layout for directed graphs.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.IEdge">
            <summary>
            an edge interface
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IEdge.Source">
            <summary>
            source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IEdge.Target">
            <summary>
            target
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.LayoutChangeEventArgs">
            <summary>
            At the moment it is an empty class
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.GeometryObject">
            <summary>
            The base class of the Graph,Node and Edge classes
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryObject.GetRestoreData">
            <summary>
            calculates the restore data
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.GeometryObject.Parent">
            <summary>
            the parent of the object
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryObject.UserData">
            <summary>
            keeps the back pointer to the user data
            </summary>
        </member>
        <member name="E:Microsoft.Msagl.GeometryObject.LayoutChangeEvent">
            <summary>
            event signalling that the layout has changed
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryObject.BoundingBox">
            <summary>
            gets or sets the boundary box of a GeometryObject
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.Stem">
            <summary>
            represents a chunk of a hole boundary
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.Polygon">
            <summary>
            the polygon is going clockwise
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.GetLeftTangentPoint(Microsoft.Msagl.Point)">
            <summary>
            the polygon lies to the right from the ray from the pivot to the tangent point
            </summary>
            <param name="pivot"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ShrinkChunkForLeftTangentSearch(Microsoft.Msagl.Point,System.Int32@,System.Int32@,Microsoft.Msagl.Visibility.PolygonRegion@,Microsoft.Msagl.Visibility.PolygonRegion@)">
            <summary>
            we know that the tangent point belongs to the chain going from i to j clockwise
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="j"></param>
            <param name="iRegion"></param>
            <param name="jRegion"></param>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ChainContainsLeftTangent(Microsoft.Msagl.Point,System.Int32,System.Int32,Microsoft.Msagl.Visibility.PolygonRegion,Microsoft.Msagl.Visibility.PolygonRegion)">
            <summary>
            the chain is going clockwise from i to m
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="m"></param>
            <param name="iRegion"></param>
            <param name="mRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ChainStartingSEContainsLeftTangent(Microsoft.Msagl.Point,System.Int32,System.Int32,Microsoft.Msagl.Visibility.PolygonRegion)">
            <summary>
            we know that i starts at se
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="m"></param>
            <param name="mRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ChainStartingSWContainsLeftTangent(Microsoft.Msagl.Point,System.Int32,System.Int32,Microsoft.Msagl.Visibility.PolygonRegion)">
            <summary>
            chain starts at SW
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="m"></param>
            <param name="mRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.GetRightTangentPoint(Microsoft.Msagl.Point)">
            <summary>
            the polygon lies to the left from the ray from the pivot to the tangent point
            </summary>
            <param name="pivot"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ShrinkChunkForRightTangentSearch(Microsoft.Msagl.Point,System.Int32@,System.Int32@,Microsoft.Msagl.Visibility.PolygonRegion@,Microsoft.Msagl.Visibility.PolygonRegion@)">
            <summary>
            we know that the tangent point belongs to the chain going from i to j clockwise
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="j"></param>
            <param name="iRegion"></param>
            <param name="jRegion"></param>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ChainContainsRightTangent(Microsoft.Msagl.Point,System.Int32,System.Int32,Microsoft.Msagl.Visibility.PolygonRegion,Microsoft.Msagl.Visibility.PolygonRegion)">
            <summary>
            the chain is going clockwise from i to m
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="m"></param>
            <param name="iRegion"></param>
            <param name="mRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ChainStartingSEContainsRightTangent(Microsoft.Msagl.Point,System.Int32,System.Int32,Microsoft.Msagl.Visibility.PolygonRegion)">
            <summary>
            we know that i starts at SE
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="m"></param>
            <param name="mRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.ChainStartingSWContainsRightTangent(Microsoft.Msagl.Point,System.Int32,System.Int32,Microsoft.Msagl.Visibility.PolygonRegion)">
            <summary>
            chain starts at SW
            </summary>
            <param name="pivot"></param>
            <param name="i"></param>
            <param name="m"></param>
            <param name="mRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.Median(System.Int32,System.Int32)">
            <summary>
            the median of a chunk going clockwise from p1 to p2
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.Polygon.FindTheFurthestVertexFromBisector(System.Int32,System.Int32,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            p1 and p2 represent the closest feature. Two cases are possible p1=p2, or p1 and p2 share an edge going from p1 to p2
            Remind that the polygons are oriented clockwise
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="bisectorPivot"></param>
            <param name="bisectorRay"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Splines.Ellipse">
            <summary>
            A class representing an ellipse.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.ICurve">
            <summary>
            The interface for curves: instances of ICurve inside of GLEE
            are BSpline,Curve,LineSeg, Ellipse,CubicBezierSeg and ArrowTipCurve.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.FirstDerivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.Translate(Microsoft.Msagl.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.OffsetCurve(System.Double,Microsoft.Msagl.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.Transform(Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.ClosestParameter(Microsoft.Msagl.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ICurve.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.BBox">
            <summary>
            XY bounding box of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ICurve.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.OffsetCurve(System.Double,Microsoft.Msagl.Point)">
            <summary>
            offsets the curve in the given direction
            </summary>
            <param name="offset">the width of the offset</param>
            <param name="dir">the direction of the offset</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.Reverse">
            <summary>
            Reverse the ellipe: not implemented.
            </summary>
            <returns>returns the reversed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.Trim(System.Double,System.Double)">
            <summary>
            Trims the curve
            </summary>
            <param name="start">the trim start parameter</param>
            <param name="end">the trim end parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.FirstDerivative(System.Double)">
            <summary>
            first derivative
            </summary>
            <param name="t">the p</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.#ctor(System.Double,System.Double,Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            Ellipse constructor, ellipse is going counter clockwise
            </summary>
            <param name="parStart">start angle in radians</param>
            <param name="parEnd">end angle in radians</param>
            <param name="axis0">x radius</param>
            <param name="axis1">y radius</param>
            <param name="center">x coordinate of the center</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.#ctor(System.Double,System.Double,Microsoft.Msagl.Point,Microsoft.Msagl.Point,System.Double,System.Double)">
            <summary>
            Ellipse constructor, ellipse is going counter clockwise
            </summary>
            <param name="parStart">start angle in radians</param>
            <param name="parEnd">end angle in radians</param>
            <param name="axis0">an axis</param>
            <param name="axis1">an axis</param>
            <param name="centerX">x coordinate of the center</param>
            <param name="centerY">y coordinate of the center</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.#ctor(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            Construct a full ellipse by two axes
            </summary>
            <param name="axis0">an axis</param>
            <param name="axis1">an axis</param>
            <param name="center"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.#ctor(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            Constructs a full ellipse with axes aligned to X and Y directions
            </summary>
            <param name="axisA">the length of the X axis</param>
            <param name="axisB">the length of the Y axis</param>
            <param name="center"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.Translate(Microsoft.Msagl.Point)">
            <summary>
            Moves the ellipse to the delta vector
            </summary>
            <param name="delta"></param>
            <returns>the moved ellipse</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.Transform(Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            Transforms the ellipse
            </summary>
            <param name="transformation"></param>
            <returns>the transformed ellipse</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] : not implemented
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Ellipse.ClosestParameter(Microsoft.Msagl.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns>the parameter of the closest point</returns>     
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.Start">
            <summary>
            Returns the start point of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.End">
            <summary>
            Returns the end point of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.AxisA">
            <summary>
            An axis of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.AxisB">
            <summary>
            An axis of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.Center">
            <summary>
            the center of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.BBox">
            <summary>
            The bounding box of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.ParallelogramNodeOverICurve">
            <summary>
            a tree of ParallelogramNodes covering the edge
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.ParStart">
            <summary>
            the start of the parameter domain
            </summary>   
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Ellipse.Length">
            <summary>
            Return the length of the ellipse curve: not implemented
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.IntPair">
            <summary>
            Represents a couple of integers.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.IntPair.op_LessThan(Microsoft.Msagl.IntPair,Microsoft.Msagl.IntPair)">
            <summary>
             the less operator
            </summary>
            <param name="pair0"></param>
            <param name="pair1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntPair.op_GreaterThan(Microsoft.Msagl.IntPair,Microsoft.Msagl.IntPair)">
            <summary>
            the greater operator
            </summary>
            <param name="pair0"></param>
            <param name="pair1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntPair.Compare(Microsoft.Msagl.IntPair,Microsoft.Msagl.IntPair)">
            <summary>
            Compares two pairs
            </summary>
            <param name="pair0"></param>
            <param name="pair1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntPair.Equals(System.Object)">
            <summary>
            override the equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntPair.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntPair.#ctor(System.Int32,System.Int32)">
            <summary>
            the constructor
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="M:Microsoft.Msagl.IntPair.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.IntPair.First">
            <summary>
            the first element of the pair
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntPair.Second">
            <summary>
            the second element of the pair
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.IntEdge">
            <summary>
            An edge with source and target represented as integers, they point to an array of Nodes of the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.IntEdge.#ctor(System.Int32,System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="M:Microsoft.Msagl.IntEdge.Revert">
            <summary>
            This function changes the edge by swapping 
            source and target. However Revert(Revert) does not change it.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.IntEdge.#ctor(System.Int32,System.Int32,Microsoft.Msagl.Edge)">
            <summary>
            constructor
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.IntEdge.Equals(System.Object)">
            <summary>
            compares only source and target
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntEdge.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntEdge.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.IntEdge.GetEnumerator">
            <summary>
            enumerates over virtual virtices corresponding to the original edge
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.Source">
            <summary>
            the source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.Target">
            <summary>
            the edge target
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.Reversed">
            <summary>
            An edge can be reversed to keep the graph acyclic
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.IsVirtualEdge">
            <summary>
            A dummy edge that will not be drawn; serves just as a place holder.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.HasLabel">
            <summary>
            Returns true if the edge has label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.LabelWidth">
            <summary>
            Label width
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.LabelHeight">
            <summary>
            Label height
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.Edge">
            <summary>
            The original edge corresponding to the IntEdge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.Separation">
            <summary>
            the distance between the source and the target in the number of layers
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.LayerSpan">
            <summary>
            the edge span in layers
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.IntEdge.LayerEdges">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Mds.TreeNode.l">
            <summary>
            left child
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Mds.TreeNode.r">
            <summary>
            right child
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.RankingLayoutSettings">
            <summary>
            Ranking layout settings
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Mds.RankingLayoutSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Mds.RankingLayoutSettings.PivotNumber">
            <summary>
            Number of pivots in Landmark Scaling (between 3 and number of objects).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.RankingLayoutSettings.OmegaX">
            <summary>
            Impact of group structure on layout in the x-axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.RankingLayoutSettings.OmegaY">
            <summary>
            Impact of group structure on layout in the y-axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.RankingLayoutSettings.ScaleX">
            <summary>
            X Scaling Factor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.RankingLayoutSettings.ScaleY">
            <summary>
            Y Scaling Factor.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.ParallelogramInternalTreeNode">
            <summary>
            An internal node of ParallelogramNodeOverICurve hierarchy.
            Is used in curve intersections routines.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.ParallelogramNodeOverICurve">
            <summary>
            Serves to hold a Parallelogram and a ICurve,
            and is used in curve intersections routines.
            The node can be a top of the hierarchy if its sons are non-nulls.
            The sons are either both nulls or both non-nulls
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.ParallelogramNode">
            <summary>
            Represents a node containing a parallelogram.
            Is used in curve intersections routines.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ParallelogramNode.#ctor">
            <summary>
            creates an empty node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ParallelogramNode.Parallelogram">
            <summary>
            gets or sets the parallelogram of the node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSegment(Microsoft.Msagl.Splines.ICurve)">
            <summary>
            
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.ParallelogramNodeOverICurve.CreateParallelogramOnSubSeg(System.Double,System.Double,Microsoft.Msagl.Splines.ICurve,Microsoft.Msagl.Splines.Parallelogram@)">
            <summary>
            Creates a bounding parallelogram on a curve segment
            We suppose here that the segment is convex or concave from start to end,
            that is the region bounded by the straight segment seg[start], seg[end] and the curve seg is convex
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="seg"></param>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ParallelogramNodeOverICurve.Seg">
            <summary>
            The segment bounded by the parallelogram
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ParallelogramNodeOverICurve.LeafBoxesOffset">
            <summary>
            The leafs of this node are as tight as the offset
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Splines.ParallelogramInternalTreeNode.Children">
            <summary>
            children of the node
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Msagl.Engine">
            <summary>
            This is the top level class driving the calculation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Engine.#ctor(Microsoft.Msagl.GeometryGraph,Microsoft.Msagl.BasicGraph{Microsoft.Msagl.IntEdge},Microsoft.Msagl.Database)">
            <summary>
            constructor
            </summary>
            <param name="originalGraph"></param>
            <param name="graph"></param>
            <param name="db"></param>
        </member>
        <member name="M:Microsoft.Msagl.Engine.GetLayeredGraph(System.Int32[],Microsoft.Msagl.LayerArrays@)">
            <summary>
            Creating a layered graph, a graph where each 
            edge goes only one layer down from i+1-th layer to i-th layer.
            </summary>
            <param name="layers"></param>
            <param name="layerArrays"></param>
        </member>
        <member name="M:Microsoft.Msagl.Engine.CreateDAGSkeleton">
            <summary>
            Creating a DAG with the same vertices as the original one, 
            but replacing original multiple edges with a single edge.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Engine.Run">
            <summary>
            The main calculation is done here
            </summary>       
        </member>
        <member name="M:Microsoft.Msagl.Engine.UpdateNodePositionData">
            <summary>
            pushes positions from the anchors to node Centers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Engine.GetMinWidth">
            <summary>
            
            </summary>
            <returns>return the maximal width node</returns>
        </member>
        <member name="M:Microsoft.Msagl.Engine.OptimizeEdgeLabelsLocations">
            <summary>
            put some labels to the left of the splines if it makes sense
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Engine.NotifyThatEdgesAreDone(Microsoft.Msagl.GeometryGraph)">
            <summary>
            I'm not sure how useful this method is
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:Microsoft.Msagl.Engine.CycleRemoval">
            <summary>
            Create a DAG from the given graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Engine.CalculateXLayersByGansnerNorth(Microsoft.Msagl.LayerArrays)">
            <summary>
            The function calculates y-layers and x-layers, 
            thus, in fact, defining node, including dummy nodes, locations.
            </summary>
            <param name="layerArrays"></param>
        </member>
        <member name="M:Microsoft.Msagl.Engine.CalcInitialYAnchorLocations(Microsoft.Msagl.LayerArrays,System.Double)">
            <summary>
            
            </summary>
            <param name="layerArrays"></param>
            <param name="spaceBeforeMargins"></param>
            <returns>the height of the graph+spaceBeforeMargins</returns>
        </member>
        <member name="P:Microsoft.Msagl.Engine.Brandes">
            <summary>
            If set on always forces using fast but not optimal Brandes algorithm for x-coordinate assignment.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Engine.Layout">
            <summary>
            the layout responsible for the algorithm parameters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Engine.VirtualNodeWidth">
            <summary>
            the width of dummy nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Engine.VirtualNodeHeight">
            <summary>
            the height of dummy nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Engine.DataBase">
            <summary>
            Keeps assorted data associated with the graph.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layering">
            <summary>
            the basis class for layering algorithms
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.GeometryGraphWriter">
            <summary>
            writes a GeometryGraph to a stream
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.#ctor(System.IO.Stream,Microsoft.Msagl.GeometryGraph)">
            <summary>
            Constructor
            </summary>
            <param name="streamPar">the stream to write the graph into</param>
            <param name="graphP">the graph</param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.Write">
            <summary>
            Writes the graph to a file
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryGraphWriter.xmlWriter">
            <summary>
            the xml writer
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryGraphWriter.graph">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteStartElement(Microsoft.Msagl.GeometryToken)">
            <summary>
            writes the starte element with the token
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteStringElement(Microsoft.Msagl.GeometryToken,System.String)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteStringElement(Microsoft.Msagl.GeometryToken,Microsoft.Msagl.GeometryToken)">
            <summary>
            WriteStringElement with tokens
            </summary>
            <param name="token"></param>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteStringElement(Microsoft.Msagl.GeometryToken,System.Double)">
            <summary>
            WriteStringElement with double
            </summary>
            <param name="token"></param>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteStringElement(Microsoft.Msagl.GeometryToken,System.Int32)">
            <summary>
            WriteStringElement with int
            </summary>
            <param name="token"></param>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteStringElement(Microsoft.Msagl.GeometryToken,System.Boolean)">
            <summary>
            WriteStringElement with bool
            </summary>
            <param name="token"></param>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteEndElement">
            <summary>
            writes the end element
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphWriter.WriteLayoutSettings(Microsoft.Msagl.LayoutAlgorithmSettings)">
            <summary>
            
            </summary>
            <param name="settings"></param>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraphWriter.NeedToCloseXmlWriter">
            <summary>
            if set to true then the XmlWriter will be closed after the graph writing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraphWriter.Stream">
            <summary>
            the stream to write the graph into
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraphWriter.SugiyamaSetting">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraphWriter.XmlWriter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraphWriter.Graph">
            <summary>
            the graph
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.GeometryGraphReader">
            <summary>
            reads the GeometryGraph from a file
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.#ctor(System.IO.Stream)">
            <summary>
            constructor witha given stream
            </summary>
            <param name="streamP"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.Read">
            <summary>
            Reads the graph from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadLayoutAlgorithmSettings(System.Xml.XmlReader)">
            <summary>
            reads the layout algorithm settings
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryGraphReader.xmlReader">
            <summary>
            the xml reader
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.SetXmlReader(System.Xml.XmlReader)">
             <summary>
             the xml reader
            <parameter>the reader</parameter>
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.CheckToken(Microsoft.Msagl.GeometryToken)">
            <summary>
            used only in Debug configuration
            <param name="token">the token that should be here</param>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadEndElement">
            <summary>
            reads the end element
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadPoint">
            <summary>
            return the Point
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadElementContentAsDouble">
            <summary>
             reads a double
            </summary>        
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadX">
            <summary>
            reads the x-coordinate
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadY">
            <summary>
            reads the y-coordinate
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.XmlRead">
            <summary>
            reads the line?
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadPointNode(Microsoft.Msagl.GeometryToken)">
            <summary>
            reads the Point
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadIntegerElement(Microsoft.Msagl.GeometryToken)">
            <summary>
            reads an int element
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadElementContentAsInt">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadBooleanElement(Microsoft.Msagl.GeometryToken)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadElementContentAsBoolean">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadDoubleElement(Microsoft.Msagl.GeometryToken)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraphReader.ReadElementContentAsString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraphReader.Graph">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraphReader.XmlReader">
             <summary>
             the xml reader
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.HullPointComparer.System#Collections#Generic#IComparer{Microsoft#Msagl#HullPoint}#Compare(Microsoft.Msagl.HullPoint,Microsoft.Msagl.HullPoint)">
            <summary>
            note that this function can change "deleted" member for collinear points
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Splines.PlaneTransformation">
            <summary>
            2 by 3 matrix of plane affine transformations
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.#ctor">
            <summary>
            constructs the an identity transformation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            first row, second row
            </summary>
            <param name="matrixElement00">0,0</param>
            <param name="matrixElement01">0,1</param>
            <param name="matrixElement02">0,2</param>
            <param name="matrixElement10">1,0</param>
            <param name="matrixElement11">1,1</param>
            <param name="matrixElement12">1,2</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.op_Multiply(Microsoft.Msagl.Splines.PlaneTransformation,Microsoft.Msagl.Point)">
            <summary>
            the matrix by point multiplication
            </summary>
            <param name="transformation"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.Multiply(Microsoft.Msagl.Splines.PlaneTransformation,Microsoft.Msagl.Point)">
            <summary>
            Point by matrix multiplication
            </summary>
            <param name="transformation"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.op_Multiply(Microsoft.Msagl.Splines.PlaneTransformation,Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            matrix matrix multiplication
            </summary>
            <param name="transformation"></param>][
            <param name="transformation0"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.Multiply(Microsoft.Msagl.Splines.PlaneTransformation,Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            matrix matrix multiplication
            </summary>
            <param name="transformation0"></param>
            <param name="transformation1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.op_Division(Microsoft.Msagl.Splines.PlaneTransformation,Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            matrix divided by matrix
            </summary>
            <param name="transform0"></param>
            <param name="transform1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.Divide(Microsoft.Msagl.Splines.PlaneTransformation,Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            Divid matrix by a matrix
            </summary>
            <param name="transformation0"></param>
            <param name="transformation1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.PlaneTransformation.Rotation(System.Double)">
            <summary>
            Rotation matrix
            </summary>
            <param name="angle">the angle of rotation</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.PlaneTransformation.Elements">
            <summary>
            the matrix elements
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.PlaneTransformation.Item(System.Int32,System.Int32)">
            <summary>
            i,j th element
            </summary>
            <param name="rowIndex"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.PlaneTransformation.Inverse">
            <summary>
            returns the inversed matrix
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.PlaneTransformation.UnitTransformation">
            <summary>
            unit matrix
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.PlaneTransformation.IsIdentity">
            <summary>
            checks if the matrix is an identity one
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.PlaneTransformation.Offset">
            <summary>
            returns the point of the matrix offset
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Edge">
            <summary>
            Edge of the graph
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.ILabeledObject">
            <summary>
            interface for geometry objects with labels
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.ILabeledObject.Label">
            <summary>
            the label of the object 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Edge.#ctor(Microsoft.Msagl.Node,Microsoft.Msagl.Node,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Edge constructor
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="labelWidth"></param>
            <param name="labelHeight"></param>
            <param name="edgeThickness"></param>
            <param name="arrowheadLength"></param>
        </member>
        <member name="M:Microsoft.Msagl.Edge.#ctor(Microsoft.Msagl.Node,Microsoft.Msagl.Node)">
            <summary>
            Constructs an edge without a label and with edge thickness 1.
            </summary>
            <param name="source">souce node</param>
            <param name="target">target node</param>
        </member>
        <member name="M:Microsoft.Msagl.Edge.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Edge.ToString">
            <summary>
            overrides ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Edge.GetRestoreData">
            <summary>
            gets restore data for an edge
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Edge.CreateSimpleEdgeCurve">
            <summary>
            creates a edge curve based only on the source and target geometry
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.Label">
            <summary>
            gets the label of the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.Source">
            <summary>
            id of the source node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.SourceAnchorNumber">
            <summary>
            For future use: The index of the anchor at the source node. By default is zero.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.Target">
            <summary>
            id of the target node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.TargetAnchorNumber">
            <summary>
            For future use:The index of the anchor at the target node. By default is zero.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.OriginalLabelWidth">
            <summary>
            Label width, need to backup it for transformation purposes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.OriginalLabelHeight">
            <summary>
            Original label height
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.ArrowheadAtSource">
            <summary>
            If set to true there is an arrow head at the source, the default value is false.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.ArrowheadAtTarget">
            <summary>
            If set to true then there is an arrow head at the target, the default value is true.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.ArrowheadLength">
            <summary>
            The length of arrow heads of the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.LabelBBox">
            <summary>
            The label bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.Length">
            <summary>
            applicable for MDS layouts
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.Weight">
            <summary>
            The greater is the weight the more important is keeping the edge short. It is 1 by default.
            Other values are not tested yet.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.Separation">
            <summary>
            The minimum number of levels dividing source from target: 1 means that the edge goes down at least one level.
            Separation is 1 by default. Other values are not tested yet.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.Curve">
            <summary>
            A curve representing the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.UnderlyingPolyline">
            <summary>
            the polyline of the untrimmed spline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.ArrowheadAtSourcePosition">
            <summary>
            The tip postition of the arrow head of the source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.ArrowheadAtTargetPosition">
            <summary>
            The tip position of the arrow head at the target
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.LineWidth">
            <summary>
            edge thickness
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Edge.BoundingBox">
            <summary>
            The bounding box of the edge curve
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.ProperLayeredGraph">
            <summary>
            a class representing a graph where every edge goes down only one layer
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.ProperLayeredGraph.baseGraph">
            <summary>
            the underlying basic graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.ProperLayeredGraph.InEdges(System.Int32)">
            <summary>
            enumerates over edges of a node
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.ProperLayeredGraph.OutEdges(System.Int32)">
            <summary>
            enumerates over the node outcoming edges
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.ProperLayeredGraph.InEdgesCount(System.Int32)">
            <summary>
            returns the number of incoming edges for an edge
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.ProperLayeredGraph.OutEdgesCount(System.Int32)">
            <summary>
            returns the number of outcoming edges for an edge
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.ProperLayeredGraph.SugiyamaLayoutSettings">
            <summary>
            The settings of the algorithm
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.ProperLayeredGraph.Edges">
            <summary>
            enumerates over the graph edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.ProperLayeredGraph.NodeCount">
            <summary>
            returns the node count
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.GeometryToken">
            <summary>
            tokens for the graph parser
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Label">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.MsaglGeometryGraph">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Header">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.AspectRatio">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Transform">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.TransformElement">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.NodeSeparation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LayerSeparation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Margins">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.MinNodeHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.MinNodeWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Nodes">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Edges">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Node">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Edge">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Id">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Padding">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ICurve">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Ellipse">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Curve">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LineSegment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.CubicBezierSegment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.AxisA">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.AxisB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Center">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Point">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.XCoordinate">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.YCoordinate">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.SourceNodeId">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.TargetNodeId">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LabelWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LabelHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LabelCenter">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LineWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ArrowheadAtSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ArrowheadPosition">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ArrowheadAtTarget">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Weight">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Separation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Start">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.End">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.B0">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.B1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.B2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.B3">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.UnderlyingPolyline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.UnderlyingPolylineIsNull">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.PolylineSite">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.SiteK">
            <summary>
            
            </summary>    
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.SiteV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ParStart">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ParEnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Reporting">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.RandomSeedForOrdering">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.NoGainStepsBound">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.MaxNumberOfPassesInOrdering">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Demotion">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.GroupSplit">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LabelCornersPreserveCoefficient">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.SplineCalculationDuration">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.BrandesThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LayoutAlgorithmSettings">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.SugiyamaLayoutSettings">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.MdsLayoutSettings">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.RankingLayoutSetting">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.LayoutAlgorithmType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.RepetitionCoefficientForOrdering">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.Exponent">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.IterationsWithMajorization">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.PivotNumber">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.RotationAngle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ScaleX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.ScaleY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.OmegaX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.GeometryToken.OmegaY">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.MdsGraphLayout">
            <summary>
            Class for graph layout with multidimensional scaling.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MdsGraphLayout.CalculateLayout(Microsoft.Msagl.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="geometryGraph"></param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MdsGraphLayout.ScaleToAverageEdgeLength(Microsoft.Msagl.GeometryGraph,System.Collections.Generic.Dictionary{Microsoft.Msagl.Edge,System.Double},System.Double[],System.Double[])">
            <summary>
            Scales a configuration such that the average edge length in the drawing
            equals the average of the given edge lengths.
            </summary>
            <param name="g">A graph.</param>
            <param name="length">Edge lengths.</param>
            <param name="x">Coordinates.</param>
            <param name="y">Coordinates.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MdsGraphLayout.LayoutGraphWithMds(Microsoft.Msagl.GeometryGraph,System.Double[]@,System.Double[]@)">
            <summary>
            Layouts a connected graph with Multidimensional Scaling, using
            shortest-path distances as Euclidean target distances.
            </summary>
            <param name="geometryGraph">A graph.</param>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MdsGraphLayout.LayoutConnectedComponents(Microsoft.Msagl.GeometryGraph,System.Double[]@,System.Double[]@)">
            <summary>
            Computes layout for possibly disconnected graphs by putting
            the layouts for connected components together.
            </summary>
            <param name="graph">A graph.</param>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.ComparerOfNodesForSweep.Compare(Microsoft.Msagl.Node,Microsoft.Msagl.Node)">
            <summary>
            compare the points by the distance from the center
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.LabelRestoreData">
            <summary>
            keeps a label restore data
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LabelRestoreData.#ctor(Microsoft.Msagl.Point)">
            <summary>
            constructor
            </summary>
            <param name="centerP"></param>
        </member>
        <member name="P:Microsoft.Msagl.LabelRestoreData.Center">
            <summary>
            the label center
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Point">
            <summary>
            Two dimensional point
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Point.Equals(System.Object)">
            <summary>
            overrides the equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Equality(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            overrides the equality
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_LessThan(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            overrides the less operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_GreaterThan(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            overrides the greater operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Inequality(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            the inequality operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_UnaryNegation(Microsoft.Msagl.Point)">
            <summary>
             the negation operator
            </summary>
            <param name="point0"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Negate">
            <summary>
            the negation operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Addition(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
             the addition
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Add(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
             the addition
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Subtraction(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            overrides the substraction
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Subtract(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            overrides the substraction
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Multiply(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            othe internal product
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.DotProduct(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            overrides the internal product
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Multiply(System.Double,Microsoft.Msagl.Point)">
            <summary>
            the multipliction by scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Multiply(Microsoft.Msagl.Point,System.Double)">
            <summary>
            multiplication on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Multiply(System.Double,Microsoft.Msagl.Point)">
            <summary>
             multiplication on coefficient scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Multiply(Microsoft.Msagl.Point,System.Double)">
            <summary>
             multiplication on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Division(Microsoft.Msagl.Point,System.Double)">
            <summary>
             division on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.op_Division(System.Double,Microsoft.Msagl.Point)">
            <summary>
            division on coefficient scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Divide(Microsoft.Msagl.Point,System.Double)">
            <summary>
            division on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Divide(System.Double,Microsoft.Msagl.Point)">
            <summary>
            division on coefficient scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.#ctor(System.Double,System.Double)">
            <summary>
            construct the point from x and y coordinates
            </summary>
            <param name="xCoordinate"></param>
            <param name="yCoordinate"></param>
        </member>
        <member name="M:Microsoft.Msagl.Point.Rotate(System.Double)">
            <summary>
            returns this rotated by coefficient anticlickwise, does not change this
            </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Normalize">
            <summary>
            creates coefficient new point with the norm 1, does not change "this" point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Angle(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            The counter-clockwise angle
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.Angle(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            The angle you need to turn "side0" counterclockwise to make it collinear with "side1"
            </summary>
            <param name="side0"></param>
            <param name="side1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.SignedDoubledTriangleArea(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            If the area is negative then C lies to the right of the line [cornerA, cornerB] or, in another words, the triangle (A , B, C) is oriented clockwize
            If it is positive then C lies ot he left of the line [A,B] another words, the triangle A,B,C is oriented counter-clockwize.
            Otherwise A ,B and C are collinear.
            </summary>
            <param name="cornerA"></param>
            <param name="cornerB"></param>
            <param name="cornerC"></param>
            <returns></returns>        
        </member>
        <member name="M:Microsoft.Msagl.Point.GetTriangleOrientation(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            figures out the triangle on the plane orientation: positive- counterclockwise, negative - clockwise
            </summary>
            <param name="cornerA"></param>
            <param name="cornerB"></param>
            <param name="cornerC"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.ClosestParameterOnLineSegment(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            return parameter on the segment [side1,cornerC] which is closest to coefficient
            </summary>
            <param name="point"></param>
            <param name="segStart"></param>
            <param name="segEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.CanProject(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            returns true if an orthogonal projection of point on [segmentStart,segmentEnd] exists
            </summary>
            <param name="point"></param>
            <param name="segmentStart"></param>
            <param name="segmentEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.ClosestPointAtLineSegment(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            The closest point on the segment [side1,cornerC] to coefficient. 
            See the drawing DistToLineSegment.gif.
            </summary>
            <param name="point"></param>
            <param name="segmentStart"></param>
            <param name="segmentEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.PointToTheLeftOfTheLine(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
             <summary>
            returns true if a lies to the left of the line linePoint0, linePoint1 
             </summary>
             <param name="a"></param>
             <param name="linePoint0"></param>
             <param name="linePoint1"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.PointToTheRightOfTheLine(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
             <summary>
            returns true if a lies to the right of the line linePoint0, linePoint1 
             </summary>
             <param name="a"></param>
             <param name="linePoint0"></param>
             <param name="linePoint1"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Point.CompareTo(Microsoft.Msagl.Point)">
            <summary>
            compares two points in the lexigraphical order
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Point.Length">
            <summary>
            the point norm
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Point.X">
            <summary>
            the x coordinate
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Point.Y">
            <summary>
            the y coordinate
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.TriangleOrientation">
            <summary>
            triangle orientations
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.TriangleOrientation.Clockwise">
            <summary>
            clockwise orientation
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.TriangleOrientation.Counterclockwise">
            <summary>
            counter clockwise orientation
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.TriangleOrientation.Collinear">
            <summary>
            the points are collinear
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.ConvexHull">
            <summary>
            Creates the convex hull of a set of points following "Computational Geometry, second edition" of O'Rourke
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.ConvexHull.CalculateConvexHull(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Point})">
            <summary>
            calculates the convex hull of the given set of points
            </summary>
            <param name="pointsOfTheBody">Point of the convex hull.</param>
            <returns>The list of extreme points of the hull boundaries in the clockwise order</returns>
        </member>
        <member name="M:Microsoft.Msagl.ConvexHull.Dispose">
            <summary>
            disposing
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.Rectangle">
            <summary>
            Just a rectangle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.Intersect(Microsoft.Msagl.Splines.Rectangle)">
            <summary>
            returns true if r intersect this rectangle
            </summary>
            <param name="rectangle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.CreateAnEmptyBox">
            <summary>
            creates an empty rectangle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.#ctor(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            create a box of two points
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.#ctor(Microsoft.Msagl.Point)">
            <summary>
            create rectangle from a point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.#ctor(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            
            </summary>
            <param name="left">left</param>
            <param name="bottom">bottom</param>
            <param name="sizeF">size</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            create a box on points (x0,y0), (x1,y1)
            </summary>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.#ctor(Microsoft.Msagl.Splines.Rectangle,Microsoft.Msagl.Splines.Rectangle)">
            <summary>
            rectangle containing both a and side1
            </summary>
            <param name="rectangle0"></param>
            <param name="rectangle1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.Contains(Microsoft.Msagl.Point,System.Double)">
            <summary>
            contains with padding
            </summary>
            <param name="point"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.Add(Microsoft.Msagl.Point)">
            <summary>
            adding a point to the rectangle
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.AddWithCheck(Microsoft.Msagl.Point)">
            <summary>
            extend the box to keep the point.
            Assume here that the box is initialized correctly
            </summary>
            <param name="point"></param>
            <returns>true if the box has been extended</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.Add(Microsoft.Msagl.Splines.Rectangle)">
            <summary>
            adding rectangle
            </summary>
            <param name="rectangle"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.op_Equality(Microsoft.Msagl.Splines.Rectangle,Microsoft.Msagl.Splines.Rectangle)">
            <summary>
            override ==
            </summary>
            <param name="rectangle0"></param>
            <param name="rectangle1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.op_Inequality(Microsoft.Msagl.Splines.Rectangle,Microsoft.Msagl.Splines.Rectangle)">
            <summary>
            overrides !=
            </summary>
            <param name="rectangle0"></param>
            <param name="rectangle1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Rectangle.Contains(Microsoft.Msagl.Point)">
            <summary>
            returns true if the rectangle contains the point
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Center">
            <summary>
            the center of the bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Left">
            <summary>
            the left of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Right">
            <summary>
            the right of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Top">
            <summary>
            the top of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Bottom">
            <summary>
            the bottom of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.LeftBottom">
            <summary>
            the left bottom corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.RightTop">
            <summary>
            the right top corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.LeftTop">
            <summary>
            the left top corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.RightBottom">
            <summary>
            the right bottom corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Width">
            <summary>
            the width of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.IsEmpty">
            <summary>
            returns true is the height or width equal to zero
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Height">
            <summary>
            Height of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Rectangle.Area">
            <summary>
            Rectangle area
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.LineSegment">
            <summary>
            Line segment
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.OffsetCurve(System.Double,Microsoft.Msagl.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.#ctor(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            construct a line segment
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.#ctor(Microsoft.Msagl.Point,System.Double,System.Double)">
            <summary>
            constructs a line segment
            </summary>
            <param name="a">the first point</param>
            <param name="x">x-coordinate of the second point</param>
            <param name="y">y-coordinate of the second point</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            constructs a line segment
            </summary>
            <param name="x0">x-coordinate of the first point</param>
            <param name="y0">y-coordinate of the first point</param>
            <param name="x1">x-coordinate of the second point</param>
            <param name="y1">y-coordinate of the second point</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.FirstDerivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.ToString">
            <summary>
            overrides ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.Translate(Microsoft.Msagl.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.Transform(Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.LineSegment.ClosestParameter(Microsoft.Msagl.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.Start">
            <summary>
            the line start point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.End">
            <summary>
            the line end point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.ParStart">
            <summary>
            the start parameter
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.ParEnd">
            <summary>
            the end parameter
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.LineSegment.BBox">
            <summary>
            The bounding box of the line
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Anchor">
             <summary>
             Defines the anchors for a node; anchors can be not symmetrical in general
             
                      |TopAnchor
            Left anchor|
             ======Origin==================RightAnchor
                      |
                      |
                      |BottomAnchor
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.Anchor.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Anchor.#ctor(Microsoft.Msagl.GeometryGraph)">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Anchor.#ctor(System.Double,System.Double,System.Double,System.Double,Microsoft.Msagl.Node,Microsoft.Msagl.GeometryGraph)">
            <summary>
            constructor
            </summary>
            <param name="leftAnchor"></param>
            <param name="rightAnchor"></param>
            <param name="topAnchor"></param>
            <param name="bottomAnchor"></param>
            <param name="node"></param>
            <param name="parent"></param>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Layout">
            <summary>
            the layout responsible for the algorithm parameters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.LeftAnchor">
            <summary>
            distance for the center of the node to its left boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.RightAnchor">
            <summary>
            distance from the center of the node to its right boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.TopAnchor">
            <summary>
            distance from the center of the node to its top boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.BottomAnchor">
            <summary>
            distance from the center of the node to it bottom boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Left">
            <summary>
            Left boundary of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Right">
            <summary>
            right boundary of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Top">
            <summary>
            top boundary of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Bottom">
            <summary>
            bottom of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.LeftTop">
            <summary>
            Left top corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.LeftBottom">
            <summary>
            Left bottom of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.RightBottom">
            <summary>
            Right bottom of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.RightTop">
            <summary>
            Right top of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.X">
            <summary>
            the x position
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Y">
            <summary>
            the y position
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Origin">
            <summary>
            Center of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.AlreadySitsOnASpline">
            <summary>
            signals if the spline has been routed already through the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Width">
            <summary>
            node widths
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Height">
            <summary>
            node height
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.RepresentsLabel">
            <summary>
            set to true if the anchor has been introduced for a label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.LabelOnTheLeft">
            <summary>
            An anchor for an edge label with the label to the right of the spline has its height equal to the one of the label
            Its leftAnchor is a reserved space for the spline and the rightAnchor is equal to the label width.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.LabelOnTheRight">
            <summary>
            An anchor for an edge label with the label to the left of the spline has its height equal to the one of the label
            Its rightAnchor is a reserved space for the spline and the leftAnchor is equal to the label width.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.PolygonalBoundary">
            <summary>
            the polygon representing the boundary of a node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Anchor.Padding">
            <summary>
            node padding
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.VertexId">
            <summary>
            Parallelogram vertex type. 
            The clockwise order of vertices is Corner, A, OtherCorner,B
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.VertexId.Corner">
            <summary>
            the basic corner vertex
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.VertexId.VertexA">
            <summary>
            a vertex adjacent to the basic corner
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.VertexId.OtherCorner">
            <summary>
            the corner opposite to the basic corner
            </summary>           
        </member>
        <member name="F:Microsoft.Msagl.Splines.VertexId.VertexB">
            <summary>
            another vertex adjacent to the basic corner
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.Parallelogram">
            <summary>
            It is a parallelogram with the vertices corner, corner+coeff,corner+coeff+side1 and corner+side1.
            Parallelograms are used by GLEE in curve intersections routines.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Parallelogram.ToString">
            <summary>
            to string 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Parallelogram.#ctor(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            Constructs the parallelogram by the corner and two sides.
            </summary>
            <param name="corner">the corner</param>
            <param name="sideA">a side</param>
            <param name="sideB">another side</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Parallelogram.Contains(Microsoft.Msagl.Point)">
            <summary>
            Return true if the parallelogram contains the point
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Parallelogram.Vertex(Microsoft.Msagl.Splines.VertexId)">
            <summary>
            Return the correspoingin vertex of the parallelogram
            </summary>
            <param name="vertexPar">vertex kind</param>
            <returns>vertex value</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Parallelogram.Intersect(Microsoft.Msagl.Splines.Parallelogram,Microsoft.Msagl.Splines.Parallelogram)">
            <summary>
            returns true if parallelograms intersect
            </summary>
            <param name="parallelogram0"></param>
            <param name="parallelogram1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Parallelogram.GetParallelogramOfAGroup(System.Collections.Generic.List{Microsoft.Msagl.Splines.Parallelogram})">
            <summary>
            create a Parallelogram over a group
            </summary>
            <param name="boxes">group of boxes</param>
            <returns>xy box</returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Parallelogram.Area">
            <summary>
            return the area of the parallelogram
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.EllipseOffset">
            <summary>
            the ellipse offset curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.ClosestParameter(Microsoft.Msagl.Point)">
            <summary>
            
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.FirstDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.LengthPartial(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.Translate(Microsoft.Msagl.Point)">
            <summary>
            
            </summary>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.OffsetCurve(System.Double,Microsoft.Msagl.Point)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.Reverse">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.SecondDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.exprPrime(System.Double,System.Double)">
            <summary>
            the first derivative of l
            </summary>
            <param name="c"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.exprPrimePrime(System.Double,System.Double)">
            <summary>
            the second derivative of l
            </summary>
            <param name="c"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.ThirdDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.Transform(Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            
            </summary>
            <param name="transformation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.Trim(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.EllipseOffset.#ctor(System.Double,System.Double,Microsoft.Msagl.Point,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="center"></param>
            <param name="offset"></param>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.Center">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.BBox">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.End">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.Length">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.ParEnd">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.ParStart">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.ParallelogramNodeOverICurve">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.Start">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.EllipseOffset.Item(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.EdgeRestoreData">
            <summary>
            holds the data needed to restore the edge after the editing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.Polyline">
            <summary>
            the underlying polyline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.LabelCenter">
            <summary>
            the initial center
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.Curve">
            <summary>
            the edge original curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.ArrowheadAtSourcePosition">
            <summary>
            the arrow head position at source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.ArrowheadAtTargetPosition">
            <summary>
            the arrow head position at target
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.LabelOffsetFromTheAttachmentPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.DistanceWhenEdgeIsTurningToLine">
            <summary>
            when we move an edge node far enough edge curve becomes a straight line
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.NumberOfPolylineSegments">
            <summary>
            number of segments in the polyline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.InitialSitePosition">
            <summary>
            the initial site position
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.Site">
            <summary>
            a site under the change
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.EdgeRestoreData.LabelAttachmentParameter">
            <summary>
            the closest point to the label center
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.XCoordsWithAlignment">
            <summary>
            The implementation follows "Fast and Simple Horizontal Coordinate Assignment" of Ulrik Brandes and Boris Kopf
            The paper has two serious bugs that this code resolves.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.XCoordsWithAlignment.infinity">
            <summary>
            Assigning xcoords starting from roots
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.XCoordsWithAlignment.LR">
            <summary>
            from left to right
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.XCoordsWithAlignment.BT">
            <summary>
            from bottom to top
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.IsVirtual(System.Int32)">
            <summary>
            Returns true if v is a virtual vertex
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.CalculateXCoordinates(Microsoft.Msagl.LayerArrays,Microsoft.Msagl.ProperLayeredGraph,System.Int32,Microsoft.Msagl.Anchor[],System.Double)">
            <summary>
            
            </summary>
            <param name="layerArrays"></param>
            <param name="layeredGraph"></param>
            <param name="nOfOriginalVs"></param>
            <param name="anchors"></param>
            <param name="ns">node separation</param>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.ConflictElimination">
            <summary>
            The code is written as if we go left up, but in fact the settings define the directions.
            
            We need to create a subgraph for alignment:
            where no edge segments intersect, and every vertex has
            at most one incoming and at most one outcoming edge.
            This function marks edges to resolve conflicts with only one inner segment.  
            An inner segment is a segment between two dummy nodes.
            We mark edges that later will not participate in the alignment. 
            Inner segments are preferred to other ones. So, in a conflict whith one inner and one 
            non-inner edges we leave the inner edge to participate in the alignment. 
            At the moment we mark as not participating both of the two intersecting inner segments
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.MarkConflictingEdges">
            <summary>
            here we eliminate all constraints 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.NextUpper(System.Int32)">
            <summary>
            parameterized next upper 
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.NextLower(System.Int32)">
            <summary>
            parameterized next lower
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.UpperOf(System.Int32,System.Int32)">
            <summary>
            parameterize highest of two numbers
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.LowerOf(System.Int32,System.Int32)">
            <summary>
            parameterized lowest of a pair
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.IsBelow(System.Int32,System.Int32)">
            <summary>
            returns parameterized below
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.LeftMost(System.Int32,System.Int32)">
            <summary>
            returns the "parameterized" left of the two positions
            </summary>
            <param name="pos0"></param>
            <param name="pos1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.RightMost(System.Int32,System.Int32)">
            <summary>
            returns the "parameterized" right of the two positions
            </summary>
            <param name="pos0"></param>
            <param name="pos1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.RightMost(System.Double,System.Double)">
            <summary>
            returns the "parameterized" right of the two positions
            </summary>
            <param name="pos0"></param>
            <param name="pos1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.IsNotRightFrom(System.Int32,System.Int32)">
            <summary>
            Return true if i is to the left or equal to pos in a "parameterized" fasion
            </summary>
            <param name="i"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.IsLeftFrom(System.Int32,System.Int32)">
            <summary>
            Parameterized left relation
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.NextRight(System.Int32)">
            <summary>
            parameterized next right
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.NextLeft(System.Int32)">
            <summary>
            parameterized next left
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.Align">
             <summary>
            Calculate the alignment based on the marked edges and greedily resolving the remaining conflicts on the fly, without marking
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.TryToGetRightNeighbor(System.Int32,System.Int32@)">
            <summary>
            returns true is u has a right neighbor on its layer
            </summary>
            <param name="u"></param>
            <param name="neighbor"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.TryToGetLeftNeighbor(System.Int32,System.Int32@)">
            <summary>
            returns true is u has a right neighbor on its layer
            </summary>
            <param name="u"></param>
            <param name="neighbor"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.CreateBlocks">
            <summary>
            Organizes the vertices into blocks. A block is a maximal path in the alignment subgraph. 
            The alignment is defined by array align. Every vertex is connected to the top vertex of 
            the block by using root array. The alignment is cyclic. If we start from a root vertex v and 
            apply align then we return to v at some point.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.XCoordsWithAlignment.DeltaBetweenVertices(System.Int32,System.Int32)">
            <summary>
            Calculates the minimum separation between two neighboring vertices: if u is to the left of v on the same layer return positive
            number, otherwise negative.
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Splines.CurveFactory">
            <summary>
            the helper class to create curves
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateEllipse(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            Creates an ellipse by the length of axes and the center
            </summary>
            <param name="radiusInXDirection"></param>
            <param name="radiusInYDirection"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateBox(System.Double,System.Double,System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            Create a rectangle with smoothed corners
            </summary>
            <param name="width">the rectangle width</param>
            <param name="height">the rectangle height</param>
            <param name="radiusInXDirection">the length of the x axis of the corner smoothing ellipse</param>
            <param name="radiusInYDirection">the length of the y axis of the corner smoothing ellipse</param>
            <param name="center">the rectangle center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateBox(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            create a box with a rad
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateHouse(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            Creates a curve resembling a house
            </summary>
            <param name="width">the house width</param>
            <param name="height">the house heigth</param>
            <param name="center">the house center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateInvHouse(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            Creates a curve resembling an inverted house
            </summary>
            <param name="width">the house width</param>
            <param name="height">the house heigth</param>
            <param name="center">the house center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateDiamond(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            Creates a curve resembling a diamond form
            </summary>
            <param name="width">the diamond width</param>
            <param name="height">the diamond heigth</param>
            <param name="center">the diamond center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateOctagon(System.Double,System.Double,Microsoft.Msagl.Point)">
            <summary>
            Creates a curve of the form of an octagon
            </summary>
            <param name="width">the octagon width</param>
            <param name="height">the octagon heigth</param>
            <param name="center">the octagon center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CurveFactory.CreateTestShape(System.Double,System.Double)">
            <summary>
            testing, don't use
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.OrderingMeasure.optimalOriginalGroupSize">
            <summary>
            for the i-th layer the optimal size of an original group is optimalOriginalGroupSize[i]
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.OrderingMeasure.optimalVirtualGroupSize">
            <summary>
            for the i-th layer the optimal size of a virtual group is optimalOriginalGroupSize[i]
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Ordering">
            <summary>
            Following "A technique for Drawing Directed Graphs" of Gansner, Koutsofios, North and Vo
            Works on the layered graph. Also see GraphLayout.pdf
            </summary>
            <summary>
            Following "A technique for Drawing Directed Graphs" of Gansner, Koutsofios, North and Vo
            Works on the layered graph. For explanations of the algorithm here see GraphLayout.pdf.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Ordering.random">
            <summary>
            this field is needed to randomly choose between transposing
            and not transposing in the adjacent exchange
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.SweepLayer(System.Int32,System.Boolean)">
            <summary>
            the layer layer-1 is fixed if 
            upperLayer us true and layer+1 is fixed in 
            the opposite case
            the layer with index "layer" is updated    
            </summary>
            <param name="layer"></param>
            <param name="upperLayer">upperLayer means if "layer" is the upperLayer 
            of the strip</param>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.Sort(System.Int32,System.Single[])">
            <summary>
            sorts layerToSort according to medianValues
            if medianValues[i] is -1 then layer[i] does not move
            </summary>
            <param name="layerToSort"></param>
            <param name="medianValues"></param>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.Init">
            <summary>
            Just depth search and assign the index saying when the node was visited
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Ordering.S">
            <summary>
            for each vertex v let S[v] be the array of successors of v
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Ordering.P">
            <summary>
            for each vertex v let P[v] be the array of predeccessors of v
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Ordering.POrder">
            <summary>
            The array contains a dictionary per vertex
            The value POrder[v][u] gives the offset of u in the array P[v]
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Ordering.SOrder">
            <summary>
            The array contains a dictionary per vertex
            The value SOrder[v][u] gives the offset of u in the array S[v]
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.InitArrays">
            <summary>
            Is called just after median layer swap is done
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.CalcPair(System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            calculates the number of intersections between edges adjacent to u and v
            </summary>
            <param name="u">a vertex</param>
            <param name="v">a vertex</param>
            <param name="cuv">the result when u is to the left of v</param>
            <param name="cvu">the result when v is to the left of u</param>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.InitPSArraysForLayer(System.Int32[])">
            <summary>
            Sweep layer from left to right and fill S,P arrays as we go.
            The arrays P and S will be sorted according to X. Note that we will not keep them sorted
            as we doing adjacent swaps. Initial sorting only needed to calculate initial clr,crl values.
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.CountOnArrays(System.Int32[],System.Int32[])">
            <summary>
            we just need to count inversions between elements of unbs and vnbs
            </summary>
            <param name="unbs">neighbors of u but only from one layer</param>
            <param name="vnbs">neighbors of v from the same layers</param>
            <returns>number of intersections when u is to the left of v</returns>
        </member>
        <member name="M:Microsoft.Msagl.Ordering.AdjacentSwapToTheRight(System.Int32[],System.Int32)">
            <summary>
            swaps i-th element with i+1
            </summary>
            <param name="layer">the layer to work on</param>
            <param name="i">the position to start</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Ordering.SeedOfRandom">
            <summary>
            gets the random seed for some random choices inside of layer ordering
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Ordering.MaxOfIterations">
            <summary>
            an upper limit on a number of passes in layer ordering
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Ordering.MaxNumberOfAdjacentExchanges">
            <summary>
            Gets or sets the number of of passes over all layers to rung adjacent exchanges, where every pass goes '
            all way up to the top layer and down to the lowest layer
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.LayerArrays">
            <summary>
            Keeps all information about the hierarchy of layers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerArrays.DropEmptyLayers">
            <summary>
            Returns the same arrays but with no empty layers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.LayerArrays.ReversedClone">
            <summary>
            returns the layer hierarchy where the order of the layers is reversed
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.LayerArrays.X">
            <summary>
            gives the order of the vertices in the y-layer
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.LayerArrays.Layers">
            <summary>
            Layers[i] is the array of vertices of i-th layer
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.DoublePriorityQueue`1">
            <summary>
            Priority queue. Priorities are double values not
            necessarily unique.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Msagl.Mds.DoublePriorityQueue`1.Count">
            <summary>
            Gives the number of elements in the queue.
            </summary>
            <returns>The number of elements.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.DoublePriorityQueue`1.Insert(`0,System.Double)">
            <summary>
            Inserts element at given priority.
            </summary>
            <param name="element">An element.</param>
            <param name="priority">The priority.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.DoublePriorityQueue`1.SetPriority(`0,System.Double)">
            <summary>
            Sets priority for an element.
            </summary>
            <param name="element">An element.</param>
            <param name="priority">The new priority.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.DoublePriorityQueue`1.DeleteMin(System.Double@)">
            <summary>
            Deletes an element with the minimum priority and returns it.
            Tie-break (more than one element with same minimum priority)
            is done randomly. Minimum priority is written to the argument.
            </summary>
            <param name="priority">The minimum priority.</param>
            <returns>An element with minimum priority.</returns>
        </member>
        <member name="T:Microsoft.Msagl.SingleSourceSingleTargetShortestPath">
            <summary>
            In graph theory, the single-source shortest path problem is 
            the problem of finding a path between two vertices such that the sum of the
             weights of its constituent edges is minimized. More formally, given a 
             weighted graph (that is, a set V of vertices, a set E of edges, 
             and a real-valued weight function f : E ? R), and given 
             further two elements n, n' of N, find a path P from n to n' so that 
             the sum of {f(p):p in P}	is minimal among all paths connecting n to n'.
             Here we use Dijkstra algorithm to find the path, and use the
             given upper bound for the speed up.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.SingleSourceSingleTargetShortestPath.GetPath">
            <summary>
            Returns  a  path
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.SingleSourceSingleTargetShortestPath.#ctor(Microsoft.Msagl.BasicGraph{Microsoft.Msagl.WeightedEdge},System.Int32,System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="graph">the graph</param>
            <param name="source">the source of a path</param>
            <param name="target">the target of a path</param>
            <param name="udist">the upper distance; it is given here that the distance from source to target is no more than udist</param>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.PolygonRegion">
            <summary>
            see the PolygonRegions.jpg
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.ParallelogramBinaryTreeNode">
            <summary>
            Keeps left and right sons of the node. Is used in curve intersections routines.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.PhyloTree">
            <summary>
            Implements a phylogenetic tree
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.GeometryGraph">
            <summary>
            This class keeps all graph information which is necessary for layout calculation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.RemoveNode(Microsoft.Msagl.Node)">
            <summary>
            Removes a node from the graph
            </summary>
            <param name="node">The node to be removed</param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.RemoveEdge(Microsoft.Msagl.Edge)">
            <summary>
            Removes an edge from the graph
            </summary>
            <param name="edge">The edge to be removed</param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.AddNode(Microsoft.Msagl.Node)">
            <summary>
            Adds a node to the graph. The node's id is unuque per whole graph.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.FindNode(System.String)">
            <summary>
            Looks for a node in the root graph
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.AddEdge(Microsoft.Msagl.Edge)">
            <summary>
            Adds a new edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.AddSameLayer(System.Collections.ObjectModel.Collection{System.String})">
            <summary>
            Nodes having the same layering: different calls generate different groups with the same layer, NOT SUPPORTED YET!
            </summary>
            <param name="nodeLabels">collection of strings - node labels</param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.CollectAllNodes">
            <summary>
            Returns the list of nodes of the graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.#ctor">
            <summary>
            Creates an empty graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.CalculateLayout">
            <summary>
            calculates the graph layout
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.IncrementalLayout(Microsoft.Msagl.Node)">
            <summary>
            adaptes to the node boundary curve change
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.PrepareUndoDragData">
            <summary>
            prepares the undo of the dragging
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.UndoDrag">
            <summary>
            undoes the dragging
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.GetRestoreData">
            <summary>
            creates graph restore data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.Save(System.String)">
            <summary>
            saves the graph to a file
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.CreateFromFile(System.String)">
            <summary>
            creates the graph from a given file
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.ExtendBoundingBox(Microsoft.Msagl.Point)">
            <summary>
            extending the graph bounding box by a point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.ExtendBoundingBoxWithCheck(Microsoft.Msagl.Point)">
            <summary>
            extends bounding box with point, returns true if the box becomes bigger
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.Translate(Microsoft.Msagl.Point)">
            <summary>
            translate the graph by delta
            </summary>
            <param name="delta">the delta of the translation</param>
        </member>
        <member name="M:Microsoft.Msagl.GeometryGraph.PumpTheBoxToTheGraph(Microsoft.Msagl.Splines.Rectangle@)">
            <summary>
            enlarge the rectangle to contain the graph
            </summary>
            <param name="b"></param>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.LayoutAlgorithmSettings">
            <summary>
            the layout responsible for the algorithm parameters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.SimpleStretch">
            <summary>
            if set to true then the layout is just stretched to fit to to AspectRatio
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.AspectRatio">
            <summary>
            The ratio width/height of the final layout. 
            The value zero means that the aspect ratio has not been set.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Transformation">
            <summary>
            This transformation is to be applied to the standard top - bottom layout.
            However, node boundaries remain unchanged.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.BoundingBox">
            <summary>
            Bounding box of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.NodeSeparation">
            <summary>
            Separation between two neighboring nodes in one layer
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.LayerSeparation">
            <summary>
            Separation between to neighboring layers
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Margins">
            <summary>
            margins width are equal from the left and from the right; they are given in percents
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.MinNodeHeight">
            <summary>
            The minimal node height
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.MinNodeWidth">
            <summary>
            The minimal node width
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Width">
            <summary>
            Width of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Height">
            <summary>
            Height of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Left">
            <summary>
            Left bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Right">
            <summary>
            Right bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.LeftBottom">
            <summary>
            Left bottom corner of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.RightTop">
            <summary>
            Right top corner of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Bottom">
            <summary>
            Bottom bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Top">
            <summary>
            Top bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.NodeCount">
            <summary>
            Returns the number of nodes in the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.EdgeCount">
            <summary>
            Return the number of edges in the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.NodeMap">
            <summary>
            the table of node IDs to nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Edges">
            <summary>
            Edges of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.GeometryGraph.Padding">
            <summary>
            the default padding of nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.PhyloTree.Leaves">
            <summary>
            the leaves of the tree
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.VisibilityGraph">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.VisibilityGraph.GetVisibilityGraphForShortestPath(Microsoft.Msagl.Point,Microsoft.Msagl.Point,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Splines.Polyline})">
            <summary>
            
            </summary>
            <param name="pathStart"></param>
            <param name="pathEnd"></param>
            <param name="obstacles"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.VisibilityGraph.FillVisibilityGraphForShortestPath(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Splines.Polyline})">
            <summary>
            Calculates the tangent visibility graph
            </summary>
            <param name="obstacles">a list of polylines representing obstacles</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Splines.BSpline">
            <summary>
            Represents a side1-spline.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.BSpline.n">
            <summary>
            number of control points -1
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.BSpline.d">
            <summary>
            control points
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.BSpline.u">
            <summary>
            knots
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.BSpline.m">
            <summary>
            length of knots-1
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.BSpline.db">
            <summary>
            intermediate de Boor points
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.BSpline.k">
            <summary>
            the current span 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.BSpline.degree">
            <summary>
            degree of the interpolating polynoms
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.#ctor(Microsoft.Msagl.Point[],System.Double[])">
            <summary>
            Creates a BSpline.
            The relation between the number of knots (m+1),the degree (p) of N_i,k and the number of control points (n+1) 
            is given by m = n + p + 1 
            </summary>
            <param name="controlPointsArray">the array of control points</param>
            <param name="knots">the array of knots</param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.FirstDerivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.Translate(Microsoft.Msagl.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.ToBezier">
            <summary>
            convert the spline to a sequences of Bezier segments
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.OffsetCurve(System.Double,Microsoft.Msagl.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.Transform(Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.Clone">
            <summary>
            crates a clone of the spline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.BSpline.ClosestParameter(Microsoft.Msagl.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.D">
            <summary>
            control points
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.U">
            <summary>
            knots
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.Degree">
            <summary>
            degree of the interpolating polynoms
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.ParStart">
            <summary>
            the start of the parameter domain
            </summary> 
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.Start">
            <summary>
            this[ParStart]
            </summary>     
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.BSpline.BBox">
            <summary>
            the bounding box of the spline
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.UnderlyingPolyline">
            <summary>
            represents the polyline of an edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.UnderlyingPolyline.FromPoints(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Point})">
             <summary>
             creates the polyline from corner points
             </summary>
            <param name="points">points of the polyline</param>
        </member>
        <member name="M:Microsoft.Msagl.UnderlyingPolyline.Clone">
            <summary>
            clones the polyline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.UnderlyingPolyline.#ctor(Microsoft.Msagl.Site)">
            <summary>
            a constructor
            </summary>
            <param name="head"></param>
        </member>
        <member name="M:Microsoft.Msagl.UnderlyingPolyline.CreateCurve">
            <summary>
            Creates a curve by using the underlying polyline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.UnderlyingPolyline.GetEnumerator">
            <summary>
            the enumerator of the polyline corners
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.UnderlyingPolyline.HeadSite">
            <summary>
            the first site of the polyline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.UnderlyingPolyline.LastSite">
            <summary>
            the last site of the polyline
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.Distances">
            <summary>
            Provides functionality for computing distances in a graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Distances.SingleSourceUniformDistances(Microsoft.Msagl.GeometryGraph,Microsoft.Msagl.Node,System.Boolean)">
            <summary>
            Computes graph-theoretic distances in a graph with uniform edge lengths.
            The distance between a node and itself is 0; the distance between a pair
            of nodes for which no connecting path exists is Double.PositiveInfinity.
            </summary>
            <param name="graph">A graph.</param>
            <param name="source">The source node for the breadth-first search.</param>
            <param name="directed">Whether the graph is directed.</param>
            <returns>An array of distances from or to the nodes to the source node.
            Nodes are indexed in their natural order when iterating over them.
            </returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Distances.SingleSourceDistances(Microsoft.Msagl.GeometryGraph,Microsoft.Msagl.Node,System.Collections.Generic.Dictionary{Microsoft.Msagl.Edge,System.Double},System.Boolean)">
            <summary>
            Dijkstra algorithm. Computes graph-theoretic distances from a node to
            all other nodesin a graph with nonnegative edge lengths.
            The distance between a node and itself is 0; the distance between a pair of
            nodes for which no connecting path exists is Double.PositiveInfinity.
            </summary>
            <param name="graph">A graph.</param>
            <param name="source">The source node.</param>
            <param name="length">A mapping from edges to lengths.</param>
            <param name="directed">Whether the graph is directed.</param>
            <returns>
            An array of distances from the source node to all nodes.
            Nodes are indexed in their natural order when iterating over them.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Distances.AllPairsDistances(Microsoft.Msagl.GeometryGraph,System.Collections.Generic.Dictionary{Microsoft.Msagl.Edge,System.Double},System.Boolean)">
            <summary>
            Computes distances between every pair of nodes in a graph.
            Distances are symmetric if the graph is undirected.
            </summary>
            <param name="graph">A graph.</param>
            <param name="length">A mapping from edges to lengths.</param>
            <param name="directed">Whether shortest paths are directed.</param>
            <returns>A square matrix with shortest path distances.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Distances.PivotDistances(Microsoft.Msagl.GeometryGraph,System.Collections.Generic.Dictionary{Microsoft.Msagl.Edge,System.Double},System.Boolean,System.Int32[])">
            <summary>
            Computes distances between a selected set of nodes and all nodes.
            Pivot nodes are selected with maxmin strategy (first at random, later
            ones to maximize distances to all previously selected ones).
            </summary>
            <param name="graph">A graph.</param>
            <param name="length">A mapping from edges to lengths.</param>
            <param name="directed">Whether shortest paths are directed.</param>
            <param name="pivotArray">Number of pivots.</param>
            <returns>A square matrix with shortest path distances.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Distances.Components(Microsoft.Msagl.GeometryGraph,System.Int32@)">
            <summary>
            Computes connected components of a graph.
            </summary>
            <param name="graph">A graph.</param>
            <param name="comps">Number of connected components.</param>
            <returns>Array of component labels.
            Nodes appear in their natural order.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Distances.ComponentGraphs(Microsoft.Msagl.GeometryGraph)">
            <summary>
            Gives graphs representing the connected components of a possibly
            disconnected graph.
            </summary>
            <param name="graph">A graph.</param>
            <returns>An array of connected components.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.TangentPair">
            <summary>
            calculates the pair of tangent line segments between two convex non-intersecting polygons H and Q
            we suppose that polygons are clockwise oriented
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.TangentPair.TangentBetweenBranches(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            we pretend here that the branches go clockwise from p0 to p1, and from q0 to q1 
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="q0"></param>
            <param name="q1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.TangentPair.FindDividingBisector(Microsoft.Msagl.Point@,Microsoft.Msagl.Point@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            following the paper of Edelsbrunner
            </summary>
            <param name="bisectorPivot"></param>
            <param name="bisectorRay"></param>
            <param name="p1">the closest feature start</param>
            <param name="p2">the closest feature end</param>
            <param name="q1">the closest feature end</param>
            <param name="q2">the closest feature start</param>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.TangentPair.OnlyOneChunkContainsExactlyTwoVertices(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            we know here that p1!=p2 and q1!=q2
            </summary>
            <param name="p2"></param>
            <param name="p1"></param>
            <param name="q2"></param>
            <param name="q1"></param>
            <param name="mp"></param>
            <param name="mq"></param>
            <param name="a1"></param>
            <param name="b1"></param>
            <param name="a2"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Splines.Curve">
            <summary>
            Curve: keeps a sequence of ICurves as its segments.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Translate(Microsoft.Msagl.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
            <param name="delta"></param>
            <returns></returns>     
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Transform(Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.LengthWithInterpolation(Microsoft.Msagl.Splines.ICurve)">
            <summary>
            An approximate length of the curve calculated using the interpolation
            </summary>
            <param name="curve"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Interpolate(System.Double,Microsoft.Msagl.Point,System.Double,Microsoft.Msagl.Point,Microsoft.Msagl.Splines.ICurve,System.Double)">
            <summary>
            interpolates the curve between parameters a and side1 as by a sequence of line segments
            </summary>
            <param name="startParameter">start parameter of the interpolation</param>
            <param name="start">start point of the interpolation</param>
            <param name="endParameter">end parameter of the interpolation</param>
            <param name="end">end point of the interpolation</param>
            <param name="curve">the interpolated curve</param>
            <param name="epsilon">the maximal allowed distance between the curve and its inerpolation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Interpolate(System.Double,System.Double,Microsoft.Msagl.Point@,System.Double,Microsoft.Msagl.Point@,Microsoft.Msagl.Splines.ICurve)">
            <summary>
            this function always produces at least two segments
            </summary>
            <param name="eps"></param>
            <param name="a"></param>
            <param name="ap"></param>
            <param name="b"></param>
            <param name="bp"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.#ctor">
            <summary>
            Constructs the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.AddSegment(Microsoft.Msagl.Splines.ICurve)">
            <summary>
            Adds a segment to the curve
            </summary>
            <param name="curve">the curve that we add a segment to</param>
            <returns>the new curve extended with the segment</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.CurveCurveIntersect(Microsoft.Msagl.Splines.ICurve,Microsoft.Msagl.Splines.ICurve,System.Boolean)">
            <summary>
            calculates all intersections between c0 and point0
            </summary>
            <param name="curve0"></param>
            <param name="curve1"></param>
            <param name="liftIntersections">if set to true parameters of the intersection point will be given in the curve parametrisation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Close(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            return true if the points are close enough
            </summary>
            <param name="pointA"></param>
            <param name="pointB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Close(System.Double,System.Double)">
            <summary>
            return true if the numbers are close enough
            </summary>
            <param name="pointA"></param>
            <param name="pointB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.CloseIntersections(Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            returns true if two intersections points are close enough
            </summary>
            <param name="intersectionPoint0"></param>
            <param name="intersectionPoint1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.GetSegmentAndParameter(System.Double,System.Double@,Microsoft.Msagl.Splines.ICurve@)">
            <summary>
            returns a relative seg parameter
            </summary>
            <param name="t"></param>
            <param name="par"></param>
            <param name="seg"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.FirstDerivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.RealCutWithClosedCurve(Microsoft.Msagl.Splines.IntersectionInfo,Microsoft.Msagl.Splines.Curve,System.Boolean)">
            <summary>
            Returns true if curves do not touch in the intersection point
            </summary>
            <param name="xx"></param>
            <param name="polygon"></param>
            <param name="onlyFromInsideCuts">if set to true and first curve is closed will return true 
            only when the second curve cuts the first one from the inside</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.RealCut(Microsoft.Msagl.Splines.IntersectionInfo,Microsoft.Msagl.Splines.Curve,System.Boolean)">
            <summary>
            
            </summary>
            <param name="xx"></param>
            <param name="polyline"></param>
            <param name="onlyFromInsideCuts">consider a cut good only if the segment cuts the polygon from inside</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.OffsetCurve(System.Double,Microsoft.Msagl.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.ClosestParameter(Microsoft.Msagl.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.TrimSplineAndCalculateArrowheads(Microsoft.Msagl.Edge,Microsoft.Msagl.Splines.ICurve,System.Boolean)">
            <summary>
            trime the edge curve with the node boundaries
            </summary>
            <param name="edge"></param>
            <param name="spline"></param>
            <param name="narrowestInterval"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.CreateBigEnoughSpline(Microsoft.Msagl.Edge)">
            <summary>
            Creates a spline between two nodes big enough to draw arrowheads
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.AddLineSegment(Microsoft.Msagl.Splines.Curve,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            adds a line segment to the curve
            </summary>
            <param name="c"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.ContinueWithLineSegment(Microsoft.Msagl.Splines.Curve,System.Double,System.Double)">
            <summary>
            adds a line segment to the curve
            </summary>
            <param name="c"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.ContinueWithLineSegment(Microsoft.Msagl.Splines.Curve,Microsoft.Msagl.Point)">
            <summary>
            adds a line segment to the curve
            </summary>
            <param name="c"></param>
            <param name="x"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Curve.CloseCurve(Microsoft.Msagl.Splines.Curve)">
            <summary>
            
            </summary>
            <param name="curve"></param>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.Segments">
            <summary>
            Returns the list of the curve segments
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.DistanceEpsilon">
            <summary>
            The distance for two points considered to be the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.IntersectionEpsilon">
            <summary>
            The distance for two intersection points considered to be the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.LineSegmentThreshold">
            <summary>
            The distance between the start and end point of a curve segment for which we consider the segment as a line segment
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.Tolerance">
            <summary>
            The distance where to real numbers are considered the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Curve.BBox">
            <summary>
            The bounding rectangle of the curve
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Arrowheads">
            <summary>
            Arrow heads calculation.
             The following holds if SmoothArrows is false. Let C be a circle with the arrow head tip 
            as the center and routing.ArrowheadLength as the radius.
            The arrow head begins where C intersects with the spline. SmoothArrows does not look good.         
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Database">
            <summary>
            This class holds assorted data associated with the graph under layout: list of anchors, 
            edges sorted by their sources,targets etc
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Database.multipleMiddles">
            <summary>
            maps middles of multiple strings to their buckets
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Database.multiedges">
            <summary>
            This table keeps multi edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Database.Anchors">
            <summary>
            Anchors of the nodes
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.EdgePathsInserter">
            <summary>
            This class is used in the case when there are multiple edges, but there is no need to dublicate layers.
            We just insert dummy nodes for edge middles without distorting the order of vertices in the layers.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.Centrality">
            <summary>
            Class for centrality computation.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Centrality.PageRank(Microsoft.Msagl.GeometryGraph,System.Double,System.Boolean)">
            <summary>
            Computes the PageRank in a directed graph.
            </summary>
            <param name="graph">A directed graph.</param>
            <param name="omega">Probability of a jump
            (with uniform probability) to some other node.</param>
            <param name="inverse">false=PageRank, true=TrustRank.</param>
            <returns>PageRank scores.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Label">
            <summary>
            A class keeping the data about an edge label
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Label.#ctor(System.Double,System.Double,Microsoft.Msagl.GeometryObject)">
             <summary>
             Constructor
             </summary>
            <param name="labelWidth">width</param>
            <param name="labelHeight">height</param>
            <param name="parentP">the corresponding edge</param>
        </member>
        <member name="M:Microsoft.Msagl.Label.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Label.GetRestoreData">
            <summary>
            creates label restore data
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Label.Center">
            <summary>
            The center of the label bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Label.Width">
            <summary>
            Width of the label: set by the user.
            Label width could be different from the original width if the layer direction 
            of the layout is horizontal. This change is used only during the calcualations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Label.Height">
            <summary>
            Height of the label: set by the user
            Label height could be different from the original height if the layer direction 
            of the layout is horizontal. This change is used only during the calcualations 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Label.BoundingBox">
            <summary>
            gets or sets the boundary box of the label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Label.AttachmentSegmentStart">
            <summary>
            the start of the segment showing the connection between the label and the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Label.AttachmentSegmentEnd">
            <summary>
            the point on the edge closest to the label center
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.CubicBezierSegment">
            <summary>
            Cubic Bezier Segment
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.CubicBezierSegment.b">
            <summary>
            control points
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.CubicBezierSegment.l">
            <summary>
            coefficients
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.CubicBezierSegment.e">
            <summary>
            coefficients
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.CubicBezierSegment.c">
            <summary>
            coefficients
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.B(System.Int32)">
            <summary>
            get a control point
            </summary>
            <param name="controlPointIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.FirstDerivative(System.Double)">
            <summary>
            first derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.#ctor(Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point,Microsoft.Msagl.Point)">
            <summary>
            the constructor
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.Translate(Microsoft.Msagl.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.OffsetCurve(System.Double,Microsoft.Msagl.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.Transform(Microsoft.Msagl.Splines.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Splines.CubicBezierSegment.ClosestParameter(Microsoft.Msagl.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.CubicBezierSegment.BBox">
            <summary>
            the segment bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.PhyloTreeLayoutCalclulation.VirtualNodeWidth">
            <summary>
            the width of dummy nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.PhyloTreeLayoutCalclulation.VirtualNodeHeight">
            <summary>
            the height of dummy nodes
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.Transformation">
            <summary>
            Class for graoh layout with Multidimensional Scaling.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Transformation.Standardize(System.Double[])">
            <summary>
            Scales and translates a vector so that all values are exactly between 0 and 1.
            </summary>
            <param name="x">Vector to be standardized.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.Transformation.Rotate(System.Double[],System.Double[],System.Double)">
            <summary>
            Rotates a 2D configuration clockwise by a given angle.
            </summary>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
            <param name="angle">Angle between 0 and 360.</param>
        </member>
        <member name="T:Microsoft.Msagl.BinaryHeapPriorityQueue">
            <summary>
            A priority queue based on the binary heap algorithm
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.BinaryHeapPriorityQueue.cache">
            <summary>
            cache[k]=A[cache[k].indexToA] this is the invariant
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.BinaryHeapPriorityQueue.#ctor(System.Int32)">
            <summary>
            the constructor
            we suppose that all integers inserted into the queue will be less then n
            </summary>
            <param name="n">it is the number of different integers that will be inserted into the queue </param>
        </member>
        <member name="M:Microsoft.Msagl.BinaryHeapPriorityQueue.DecreasePriority(System.Int32,System.Double)">
            <summary>
            sets the object priority to c
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Visibility.TangentVisibilityGraphCalculator.polygons">
            <summary>
            the list of obstacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.TangentVisibilityGraphCalculator.InitActiveDiagonals">
            <summary>
            this function will also add the first tangent to the visible edges if needed
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.TangentVisibilityGraphCalculator.TangentComparison(Microsoft.Msagl.Visibility.Tangent,Microsoft.Msagl.Visibility.Tangent)">
            <summary>
            compare tangents by measuring the counterclockwise angle between the tangent and the edge
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Splines.IntersectionInfo">
            <summary>
            Contains the result of the intersection of two ICurves.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.IntersectionInfo.#ctor(System.Double,System.Double,Microsoft.Msagl.Point,Microsoft.Msagl.Splines.ICurve,Microsoft.Msagl.Splines.ICurve)">
            <summary>
            the constructor
            </summary>
            <param name="pr0"></param>
            <param name="pr1"></param>
            <param name="x"></param>
            <param name="s0"></param>
            <param name="s1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Splines.IntersectionInfo.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.IntersectionInfo.Par0">
            <summary>
            the parameter on the first curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.IntersectionInfo.Par1">
            <summary>
            the parameter on the second curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.IntersectionInfo.IntersectionPoint">
            <summary>
            the intersection point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.IntersectionInfo.Segment0">
            <summary>
            the segment of the first curve where the intersection point belongs
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Splines.IntersectionInfo.Segment1">
            <summary>
            the segment of the second curve where the intersection point belongs
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.NodeRestoreData">
            <summary>
            node restore data
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.NodeRestoreData.Center">
            <summary>
            node center
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.NodeRestoreData.BoundaryCurve">
            <summary>
            node boundary curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.WeightedEdge.Source">
            <summary>
            source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.WeightedEdge.Target">
            <summary>
            source
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.VisibilityEdge">
            <summary>
            an edge connecting two PVertices
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.StemStartPointComparer">
            <summary>
            compares couples only by looking at the couple first point
            we need the couple to hold the stem
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Visibility.PointVisibilityCalculator">
            <summary>
            following "Visibility Algorithms in the Plane", Ghosh
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Visibility.PointVisibilityCalculator.visibleBoundaries">
            <summary>
            These are parts of hole boundaries visible from q where each node is taken in isolation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(System.Collections.Generic.List{Microsoft.Msagl.Splines.Polyline},Microsoft.Msagl.Visibility.VisibilityGraph,Microsoft.Msagl.Visibility.VisibilityGraph,Microsoft.Msagl.Point,Microsoft.Msagl.Visibility.VisibilityKind)">
            <summary>
            We suppose that the holes are convex and oriented clockwis and are mutually disjoint
            </summary>
            <param name="listOfHoles"></param>
            <param name="graphOfHoleBoundaries">this graph should not be changed</param>
            <param name="visibilityGraph"></param>
            <param name="point">The point can belong to the boundary of one of the holes</param>
            <param name="visibilityKind">tangent or regural visibility</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.PointVisibilityCalculator.SortSAndInitActiveEdges">
            <summary>
            sorts the set of potentially visible vertices around point q
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Visibility.PointVisibilityCalculator.GetInitialVisibleBoundaryStemsAndInsertActiveEdges">
            <summary>
            these are chuncks of the visible boundaries growing from the polyline  point just above its crossing with the horizontal ray or 
            from the visible part start
            In the general case we have two stems from one polyline
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Splines.Polyline">
            <summary>
            class representing a polyline
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Splines.Polyline.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Splines.Polyline.Closed">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Site">
            <summary>
            A class for keeping polyline points in a double linked list
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Site.bezierSegmentFitCoefficient">
            <summary>
            the coeffiecient used to create the Bezier segment with the fillet at the site
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Site.#ctor(Microsoft.Msagl.Point)">
            <summary>
            the constructor
            </summary>
            <param name="vp"></param>
        </member>
        <member name="M:Microsoft.Msagl.Site.#ctor(Microsoft.Msagl.Site,Microsoft.Msagl.Point)">
            <summary>
            a constructor
            </summary>
            <param name="pr"></param>
            <param name="vp"></param>
        </member>
        <member name="M:Microsoft.Msagl.Site.#ctor(Microsoft.Msagl.Site,Microsoft.Msagl.Point,Microsoft.Msagl.Site)">
            <summary>
            a constructor
            </summary>
            <param name="pr"></param>
            <param name="vp"></param>
            <param name="ne"></param>
        </member>
        <member name="P:Microsoft.Msagl.Site.BezierSegmentFitCoefficient">
            <summary>
            the coefficient tells how tight the segment fits into the corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Site.Point">
            <summary>
            gets the site point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Site.Previous">
            <summary>
            gets the previous site
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Site.Next">
            <summary>
            gets the next site
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.RefinerBetweenTwoLayers.CalculateNewBottomSite">
            <summary>
            circimvating from the side
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Set`1">
            <summary>
            an implementation of Set
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Insert(`0)">
            <summary>
            inserts an element into the set
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Contains(`0)">
            <summary>
            returns true when the set contains the element
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Delete(`0)">
            <summary>
            deletes the element from the set
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Remove(`0)">
            <summary>
            deletes the element from the set
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.GetEnumerator">
            <summary>
            returns the set entities enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Find(`0)">
            <summary>
            find the key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.CopyTo(`0[],System.Int32)">
            <summary>
            copies to an array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Clear">
            <summary>
            cleans the set
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Clone">
            <summary>
            clones the set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            constructor
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.ToArray(System.Type)">
            <summary>
            creates an array from the set elements
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.Any">
            <summary>
            returns an element from the set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Set`1.op_Addition(Microsoft.Msagl.Set{`0},Microsoft.Msagl.Set{`0})">
            <summary>
            overloading plus operator
            </summary>
            <param name="set0"></param>
            <param name="set1"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Set`1.Count">
            <summary>
            returns the number elements in the set
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Set`1.IsReadOnly">
            <summary>
            the read only flag
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Node">
            <summary>
            Node of the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Node.#ctor(System.String,Microsoft.Msagl.Splines.ICurve)">
            <summary>
            Creates a Node instance
            </summary>
            <param name="id">node name, not a null</param>
            <param name="curve">node boundaryCurve</param>
        </member>
        <member name="M:Microsoft.Msagl.Node.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Node.CompareTo(System.Object)">
            <summary>
            the comparison by ID
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Node.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Node.RemoveSelfEdge(Microsoft.Msagl.Edge)">
            <summary>
            removes a self edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Node.AddOutEdge(Microsoft.Msagl.Edge)">
            <summary>
            adds and outgoing edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Node.AddInEdge(Microsoft.Msagl.Edge)">
            <summary>
            add an incoming edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Node.AddSelfEdge(Microsoft.Msagl.Edge)">
            <summary>
            adds a self edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Node.GetRestoreData">
            <summary>
            creates node restore datat
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Node.RemoveInEdge(Microsoft.Msagl.Edge)">
            <summary>
            removes an outgoing edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Node.RemoveOutEdge(Microsoft.Msagl.Edge)">
            <summary>
            removes an incoming edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="P:Microsoft.Msagl.Node.Label">
            <summary>
            the label of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.LineWidth">
            <summary>
            the width of the node boundary curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.Id">
            <summary>
            Every node should have a unuque Id per graph including its subgraphs
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.Padding">
            <summary>
            Padding around the node: splines should not get closer than padding to the node boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.BoundaryCurve">
            <summary>
            The engine assumes that the node boundaryCurve is defined relatively to the point (0,0)
            This must be a closed curve.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.InEdges">
            <summary>
            enumeration of the node incoming edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.OutEdges">
            <summary>
            enumeration of the node outcoming edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.SelfEdges">
             <summary>
            enumeration of the node self edges
             </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.Edges">
            <summary>
            enumerates over all edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.Center">
            <summary>
            Node center
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.BoundingBox">
            <summary>
            the bounding box of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.Width">
            <summary>
            Width of the node does not include the padding
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Node.Height">
            <summary>
            Height of the node does not including the padding
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Balancing">
            <summary>
            balances the layers by moving vertices with
            the same number of input-output edges to feasible layers with fewer nodes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Balancing.vertsCounts">
            <summary>
            numbers of vertices in layers 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Balancing.Balance(Microsoft.Msagl.BasicGraph{Microsoft.Msagl.IntEdge},System.Int32[])">
            <summary>
            balances the layers by moving vertices with
            the same number of input-output edges to feasible layers with fiewer nodes  /// </summary>
            <param name="dag">the layered graph</param>
            <param name="layering">the layering to change</param>
        </member>
        <member name="M:Microsoft.Msagl.Balancing.UpdateRegionsForPossibleJumpersAndInsertJumpers(System.Int32,System.Int32)">
            <summary>
            some other jumpers may stop being ones if the jump 
            was just in to their destination layer, so before the actual 
            jump we have to recheck if the jump makes sense
            
            </summary>
            <param name="jumperLayer">old layer of jumper</param>
            <param name="jumper"></param>
        </member>
        <member name="M:Microsoft.Msagl.Balancing.CalcJumpInfo(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            layerToJumpTo is -1 if there is no jump
            </summary>
            <param name="upLayer"></param>
            <param name="lowLayer"></param>
            <param name="jumper"></param>
            <param name="jumperLayer"></param>
            <param name="layerToJumpTo"></param>
        </member>
        <member name="M:Microsoft.Msagl.Balancing.Up(System.Int32)">
            <summary>
            Up returns the first infeasible layer up from i that i cannot jump to
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Balancing.Down(System.Int32)">
            <summary>
            Returns the first infeasible layer down from i that i cannot jump to
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.PhyloEdge">
            <summary>
            Phylogenetic edge: an edge with a specified length
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.PhyloEdge.#ctor(Microsoft.Msagl.Node,Microsoft.Msagl.Node)">
            <summary>
            constructor
            </summary>
            <param name="sourceP"></param>
            <param name="targetP"></param>
        </member>
        <member name="P:Microsoft.Msagl.Visibility.Tangent.Diagonal">
            <summary>
            the diagonal will be not a null only when it is active
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.ParallelogramLeaf">
            <summary>
            A leaf of the ParallelogramNodeOverICurve hierarchy.
            Is used in curve intersectons routine.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.LinearSystem2">
            <summary>
            solves a linear system of two equations with to unknown variables
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Splines.PointLocation">
            <summary>
            Point positions relative to a closed curve enumeration
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.PointLocation.Inside">
            <summary>
            The point is inside of the curve
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.PointLocation.Outside">
            <summary>
            The point is outside of the curve
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Splines.PointLocation.Boundary">
            <summary>
            The point is on the curve boundary
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.BasicGraph`1">
            <summary>
            The base class for graphs: layering and ordering work on an instance of this class.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.BasicGraph`1.#ctor">
            <summary>
            a default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.BasicGraph`1.VertexCount(System.Collections.IEnumerable)">
            <summary>
            actually finds maximum of sources and targets+1
            </summary>
            <param name="edges"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.BasicGraph`1.#ctor(System.Collections.Generic.List{`0},System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="edges"></param>
            <param name="numberOfVerts"></param>
        </member>
        <member name="M:Microsoft.Msagl.BasicGraph`1.#ctor(`0[],System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="edges"></param>
            <param name="numberOfVerts"></param>
        </member>
        <member name="M:Microsoft.Msagl.BasicGraph`1.OutEdges(System.Int32)">
            <summary>
            Edges exiting a vertex
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.BasicGraph`1.InEdges(System.Int32)">
            <summary>
            Edges entering a vertex
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.BasicGraph`1.SetEdges(System.Collections.Generic.List{`0},System.Int32)">
            <summary>
            sets edges of the graph
            </summary>
            <param name="valEdges"></param>
            <param name="nov">number of vertices</param>
        </member>
        <member name="P:Microsoft.Msagl.BasicGraph`1.NodeCount">
            <summary>
            returning number of vertices of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.BasicGraph`1.Edges">
            <summary>
            returning all edges of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.BasicGraph`1.Nodes">
            <summary>
            array of nodes
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.MultidimensionalScaling">
            <summary>
            Classical Multidimensional Scaling. Given a set of proximities or
            dissimilarities ordistances between objects, multidimensional scaling
            recovers low-dimensional coordinates for these objects with these
            distances.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.DoubleCenter(System.Double[][])">
            <summary>
            Double-centers a matrix in such a way that the center of gravity is zero.
            After double-centering, each row and each column sums up to zero.
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.SquareEntries(System.Double[][])">
            <summary>
            Squares all entries of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.Multiply(System.Double[][],System.Double)">
            <summary>
            Multiplies a matrix with a scalar factor.
            </summary>
            <param name="matrix">A matrix.</param>
            <param name="factor">A scalar factor.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.Multiply(System.Double[][],System.Double[])">
            <summary>
            Multiply a square matrix and a vector. 
            Note that matrix width and vector length
            have to be equal, otherwise null is returned.
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.</param>
            <returns>The resulting product vector, or null if matrix and vector
            are incompatible.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.Norm(System.Double[])">
            <summary>
            Gives the norm of a vector, that is, its length in
            vector.length dimensional Euclidean space.
            </summary>
            <param name="x">A vector.</param>
            <returns>The norm of the vector.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.Normalize(System.Double[])">
            <summary>
            Normalizes a vector to unit length (1.0) in
            vector.length dimensional Euclidean space.
            If the vector is the 0-vector, nothing is done.
            </summary>
            <param name="x">A vector.</param>
            <returns>The norm of the vector.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.RandomUnitLengthVector(System.Int32,System.Int32)">
            <summary>`
            Gives a random unit Euclidean length vector of a given size.
            </summary>
            <param name="n">The size ofthe vector.</param>
            <param name="seed">A seed for the random number generator.</param>
            <returns>A random vector.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.SpectralDecomposition(System.Double[][],System.Double[]@,System.Double@,System.Double[]@,System.Double@)">
            <summary>
            Computes the two dominant eigenvectors and eigenvalues of a symmetric
            square matrix.
            </summary>
            <param name="A">A matrix.</param>
            <param name="u1">First eigenvector.</param>
            <param name="lambda1">First eigenvalue.</param>
            <param name="u2">Second eigenvector.</param>
            <param name="lambda2">Second eigenvalue.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.DotProduct(System.Double[],System.Double[])">
            <summary>
            Gives the inner product of two vectors of the same size.
            </summary>
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            <returns>The inner product of the two vectors.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.MakeOrthogonal(System.Double[],System.Double[])">
            <summary>
            Orthogonalizes a vector against another vector, so that
            their scalar product is 0.
            </summary>
            <param name="x">Vector to be orthogonalized.</param>
            <param name="y">Vector to orthogonalize against.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.ClassicalScaling(System.Double[][],System.Double[]@,System.Double[]@)">
            <summary>
            Classical multidimensional scaling.  Computes two-dimensional coordinates
            for a given distance matrix by computing the two largest eigenvectors
            and eigenvalues of a matrix assiciated with the distance matrix (called
            "fitting inner products").
            </summary>
            <param name="d">The distance matrix.</param>
            <param name="x">The first eigenvector (scaled by the root of its eigenvalue)</param>
            <param name="y">The second eigenvector (scaled by the root of its eigenvalue)</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.DistanceScalingSubset(System.Double[][],System.Double[],System.Double[],System.Double[][],System.Int32)">
            <summary>
            Multidimensional scaling.  Computes two-dimensional coordinates
            for a given distance matrix by fitting the coordinates to these distances
            iteratively by majorization (called "distance fitting").
            Only objects that have rows in the distance/weight matrix
            is subject to iterative relocation.
            </summary>
            <param name="d">A distance matrix.</param>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
            <param name="w">Weight matrix.</param>
            <param name="numberOfIterations">Number of iteration steps.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.DistanceScaling(System.Double[][],System.Double[],System.Double[],System.Double[][],System.Int32)">
            <summary>
            Multidimensional scaling.  Computes two-dimensional coordinates
            for a given distance matrix by fitting the coordinates to these distances
            iteratively by majorization (called "distance fitting").
            (McGee, Kamada-Kawai)
            </summary>
            <param name="d">A distance matrix.</param>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
            <param name="w">Weight matrix.</param>
            <param name="iter">Number of iteration steps.</param>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.ExponentialWeightMatrix(System.Double[][],System.Double)">
            <summary>
            Convenience method for generating a weight matrix from a distance matrix.
            Each output entry is the corresponding input entry powered by a constant
            exponent.
            </summary>
            <param name="d">A distance matrix.</param>
            <param name="exponent">The exponent.</param>
            <returns>A weight matrix.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.EuclideanDistanceMatrix(System.Double[],System.Double[])">
            <summary>
            Convenience method for all Euclidean distances within two-dimensional
            positions.
            </summary>
            <param name="x">Coordinates.</param>
            <param name="y">Coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MultidimensionalScaling.LandmarkClassicalScaling(System.Double[][],System.Double[]@,System.Double[]@,System.Int32[])">
            <summary>
            Approximation to classical multidimensional scaling.
            Computes two-dimensional coordinates
            for a given rectangular distance matrix.
            </summary>
            <param name="d">The distance matrix.</param>
            <param name="x">The first eigenvector (scaled by the root of its eigenvalue)</param>
            <param name="y">The second eigenvector (scaled by the root of its eigenvalue)</param>
            <param name="pivotArray">index of pivots</param>
        </member>
        <member name="M:Microsoft.Msagl.SmoothedPolyline.#ctor(Microsoft.Msagl.IntEdge,Microsoft.Msagl.Anchor[],Microsoft.Msagl.GeometryGraph,Microsoft.Msagl.LayerArrays,Microsoft.Msagl.ProperLayeredGraph,Microsoft.Msagl.Database)">
            <summary>
            Creates a smoothed polyline
            </summary>
            <param name="edgePathPar"></param>
            <param name="anchorsP"></param>
            <param name="origGraph"></param>
            <param name="la"></param>
            <param name="layerGraph"></param>
            <param name="dbP"></param>
        </member>
        <member name="T:Microsoft.Msagl.DFSCycleRemoval">
            <summary>
            Calculates a set of edges to reverse, so called "feedback set", for obtaining a DAG
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DFSCycleRemoval.#ctor">
            <summary>
            private constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DFSCycleRemoval.ConnectedComps(Microsoft.Msagl.BasicGraph{Microsoft.Msagl.IntEdge})">
            <summary>
            For a given graph creates a list of its connected components.
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DFSCycleRemoval.GetFeedbackSet(Microsoft.Msagl.BasicGraph{Microsoft.Msagl.IntEdge})">
            <summary>
            Returning a list of edges reverting which making the graph into a DAG
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DFSCycleRemoval.GetFeedbackSetFromComp(Microsoft.Msagl.BasicGraph{Microsoft.Msagl.IntEdge})">
            <summary>
            We build a spanning tree by following the DFS, the tree induces an order on vertices 
            measured by the distance from the tree root. The feedback set will consist of edges 
            directed against this order.
            </summary>
            <param name="graph">Here graph is a connected component</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.LayerEdge">
            <summary>
            This is an edge going down only one layer.
            It points to the original edge that can pass several layers
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerEdge.Equals(System.Object)">
            <summary>
            overrides the equlity
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.LayerEdge.GetHashCode">
            <summary>
            overrides GetHashCode
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.LayerEdge.Source">
            <summary>
            the source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.LayerEdge.Target">
            <summary>
            the target
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.NetworkEdge">
            <summary>
            Differs from IntEdge in containing a flag indicating belonging to the tree
            and containing the cut value
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.NetworkSimplex">
            <summary>
            the algorithm follows "A technique for Drawing Directed Graphs", Gansner, Koutsofios, North, Vo.
            Consider re-implement this algorithm following Chvatal
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.FeasibleTree">
            <summary>
            The function FeasibleTree constructs an initial feasible spanning tree.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.VertexSourceTargetVal(System.Int32,Microsoft.Msagl.NetworkEdge)">
            <summary>
            treeEdge, belonging to the tree, divides the vertices to source and target components
            If v belongs to the source component we return 1 oterwise we return 0
            </summary>
            <param name="v">a v</param>
            <param name="treeEdge">a vertex</param>
            <returns>an edge from the tree</returns>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.IncidentEdges(System.Int32)">
            <summary>
            a convenient wrapper of IncEdges
            </summary>
            <param name="v"></param>
            <returns>edges incident to v</returns>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.EdgeSourceTargetVal(Microsoft.Msagl.NetworkEdge,Microsoft.Msagl.NetworkEdge)">
            <summary>
            treeEdge, belonging to the tree, divides the vertices to source and target components
            e does not belong to the tree . If e goes from the source component to target component 
            then the return value is 1,
            if e goes from the target component ot the source then the return value is -1
            otherwise it is zero
            </summary>
            <param name="e">a non-tree edge</param>
            <param name="treeEdge">a tree edge</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.InitCutValues">
            <summary>
            The init_cutvalues function computes the cut values of the tree edges.
            For each tree edge, this is computed by marking the nodes as belonging to the source or 
            target component, and then performing the sum of the signed weights of all 
            edges whose source and target are in different components, the sign being negative for those edges 
            going from the source to the target component.
            To reduce this cost, we note that the cut values can be computed using information local to an edge 
            if the search is ordered from the leaves of the feasible tree inward. It is trivial to compute the 
            cut value of a tree edge with one of its endpoints a leaf in the tree, 
            since either the source or the target component consists of a single node. 
            Now, assuming the cut values are known for all the edges incident on a given 
            node except one, the cut value of the remaining edge is the sum of the known cut 
            values plus a term dependent only on the edges incident to the given node.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.EdgeContribution(Microsoft.Msagl.NetworkEdge,System.Int32)">
            <summary>
            e is a tree edge for which the cut has been calculted already.
            EdgeContribution gives an amount that edge e brings to the cut of parent[w].
            The contribution is the cut value minus the weight of e. Let S be the component of e source. 
            We should also substruct W(ie) for every ie going from S to w and add W(ie) going from w to S.
            These numbers appear in e.Cut but with opposite signs.
            </summary>
            <param name="e">tree edge</param>
            <param name="w">parent[w] is in the process of the cut calculation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.InitLimLowAndParent">
            <summary> 
            A quote:
            Another valuable optimization, similar to a technique described in [Ch],
            is to perform a postorder traversal of the tree, starting from some fixed 
            root node vroot, and labeling each node v with its postorder 
            traversal number lim(v), the least number low(v) of any descendant in the search, 
            and the edge parent(v) by which the node was reached (see figure 2-5).
            This provides an inexpensive way to test whether a node lies in the 
            source or target component of a tree edge, and thus whether a non-tree edge 
            crosses between the two components. For example, if e = (u,v) is a 
            tree edge and vroot is in the source component of the edge (i.e., lim(u) less lim(v)), 
            then a node w is in the target component of e if and only if low(u) is less or equal than lim(w) 
            is less or equal than lim(u). These numbers can also be used to update the tree efficiently 
            during the network simplex iterations. If f = (w,x) is the entering edge, the 
            only edges whose cut values must be adjusted are those in the path 
            connecting w and x in the tree. This path is determined by following 
            the parent edges back from w and x until the least common ancestor is reached, 
            i.e., the first node l such that low(l) is less or equal lim(w) than ,
            lim(x) is less or equal than lim(l). 
            Of course, these postorder parameters must also be adjusted when 
            exchanging tree edges, but only for nodes below l.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.InitLowLimParentAndLeavesOnSubtree(System.Int32@,System.Int32@)">
            <summary>
            initializes lim and low in the subtree 
            </summary>
            <param name="curLim">the root of the subtree</param>
            <param name="v">the low[v]</param>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.UpdateLimLowLeavesAndParentsUnderNode(System.Int32)">
            <summary>
            here we update values lim and low for the subtree with the root l
            </summary>
            <param name="l"></param>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.GetNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack">
            <summary>
            one of the returned edge vertices does not belong to the tree but another does
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.TightTree">
            <summary>
            The function TightTree finds a maximal tree of tight edges containing 
            some fixed node and returns the number of nodes in the tree. 
            Note that such a maximal tree is just a spanning tree for the subgraph 
            induced by all nodes reachable from the fixed node in the underlying 
            undirected graph using only tight edges. In particular, all such trees have the same number of nodes.
            The function also builds the tree.
            </summary>
            <returns>number of verices in a tight tree</returns>
        </member>
        <member name="M:Microsoft.Msagl.NetworkSimplex.Exchange(Microsoft.Msagl.NetworkEdge,Microsoft.Msagl.NetworkEdge)">
            <summary>
            If f = (w,x) is the entering edge, the 
            only edges whose cut values must be adjusted are those in the path 
            connecting w and x in the tree, excluding e. This path is determined by 
            following the parent edges back from w and x until the least common ancestor is 
            reached, i.e., the first node l such that low(l) less or equal lim(w) ,lim(x) less or equal lim(l). 
            Of course, these postorder parameters must also be adjusted when 
            exchanging tree edges, but only for nodes below l.
            </summary>
            <param name="e">exiting edge</param>
            <param name="f">entering edge</param>
        </member>
        <member name="T:Microsoft.Msagl.NetworkSimplex.IncEdges">
            <summary>
            to enumerate over all edges incident to v
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Mds.MdsLayoutSettings">
            <summary>
            MDL layout settings
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Mds.MdsLayoutSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Mds.MdsLayoutSettings.PivotNumber">
            <summary>
            Number of pivots in Landmark Scaling (between 3 and number of objects).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.MdsLayoutSettings.IterationsWithMajorization">
            <summary>
            Number of iterations in distance scaling
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.MdsLayoutSettings.ScaleX">
            <summary>
            X Scaling Factor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.MdsLayoutSettings.ScaleY">
            <summary>
            Y Scaling Factor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.MdsLayoutSettings.Exponent">
            <summary>
            Weight matrix exponent.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Mds.MdsLayoutSettings.RotationAngle">
            <summary>
            rotation angle
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.XLayoutGraph">
            <summary>
            Follows the idea from Gansner etc 93, creating a special graph
            for x-coordinates calculation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.XLayoutGraph.EdgeWeightMultiplier(Microsoft.Msagl.IntEdge)">
            <summary>
            following Gansner etc 93 returning weight multplier bigger if there are virtual nodes
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.XLayoutGraph.SetEdgeWeights">
            <summary>
            caching edges weights
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.LayerInserter">
            <summary>
            Preparing the graph for x-coordinate calculation by inserting dummy nodes into the layers
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.LayerInserter.layeredGraph">
            <summary>
            Old layered graph: 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.LayerInserter.nLayeredGraph">
            <summary>
            new layered graph 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.LayerInserter.la">
            <summary>
            old layer arrays
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.LayerInserter.nla">
            <summary>
            new layer arrays
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.#ctor(Microsoft.Msagl.ProperLayeredGraph,Microsoft.Msagl.LayerArrays,Microsoft.Msagl.Database,Microsoft.Msagl.BasicGraph{Microsoft.Msagl.IntEdge})">
            <summary>
            constructor
            </summary>
            <param name="layeredGraph"></param>
            <param name="la"></param>
            <param name="db"></param>
            <param name="intGraphP"></param>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.InsertLayers">
            <summary>
            does the main work
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.EditOldLayering">
            <summary>
            virtual nodes inside of a node should be of the form i,i+1, ....
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.WidenOriginalLayers">
            <summary>
            Original layers are represented by even layers in the new layering.
            Here we add new virtices in such layers and 
            set new x-offsets of original and dummy vertices in these layers.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.FillUnsortedNewOddLayers">
            <summary>
            filling new layers not corresponding to the original layers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.MapVirtualNodesToEdges">
            <summary>
            create the mapping from the vertices to edges to which they belong
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.CreateFullLayeredGraph">
            <summary>
            Creating buckets for multi edges and allocating the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.SortNewOddLayers">
            <summary>
            Sort new odd layers by the sum of x-coordinatates of predecessors and the successors of 
            dummy nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.LayerInserter.InitNewLayering">
            <summary>
            Allocating new layering and filling its y-layers
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.LayerInserter.NLayering">
            <summary>
            new Y-layering
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.LongestPathLayering">
            <summary>
            Layering the DAG by longest path
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.TopologicalSort">
            <summary>
            Implements the topological sort
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.TopologicalSort.#ctor">
            <summary>
            private constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.TopologicalSort.GetOrder(Microsoft.Msagl.BasicGraph{Microsoft.Msagl.IntEdge})">
            <summary>
            The function returns an array arr such that
            arr is a permutation of the graph vertices,
            and for any edge e in graph if e.Source=arr[i]
            e.Target=arr[j], then i is less than j
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
    </members>
</doc>
